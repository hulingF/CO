# 深入浅出计算机组成原理1

## 原理篇：指令与运算

### 1.计算机指令：让我们试试用纸带编程

你在学写程序的时候，有没有想过，古老年代的计算机程序是怎么写出来的？

上大学的时候，我们系里教 C 语言程序设计的老师说，他们当年学写程序的时候，不像现在这样，都是用一种古老的物理设备，叫作`“打孔卡（Punched Card）”`。用这种设备写程序，可没法像今天这样，掏出键盘就能打字，而是要先在脑海里或者在纸上写出程序，然后在纸带或者卡片上打洞。`这样，要写的程序、要处理的数据，就变成一条条纸带或者一张张卡片，之后再交给当时的计算机去处理。`

![image-20230105090549281](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105090549281.png)

你看这个穿孔纸带是不是有点儿像我们现在考试用的答题卡？那个时候，人们在特定的位置上打洞或者不打洞，来代表`“0”`或者`“1”`。

为什么早期的计算机程序要使用打孔卡，而不能像我们现在一样，用 C 或者 Python 这样的高级语言来写呢？`原因很简单，因为计算机或者说 CPU 本身，并没有能力理解这些高级语言。`即使在 2019 年的今天，我们使用的现代个人计算机，仍然只能处理所谓的“机器码”，也就是一连串的“0”和“1”这样的数字。

那么，我们每天用高级语言的程序，最终是怎么变成一串串“0”和“1”的？这一串串“0”和“1”又是怎么在 CPU 中处理的？今天，我们就来仔细介绍一下，`“机器码”`和`“计算机指令”`到底是怎么回事。

#### 1.1在软硬件接口中，CPU 帮我们做了什么事？

我们常说，CPU 就是计算机的大脑。CPU 的全称是 Central Processing Unit，中文是`中央处理器`。我们上一节说了，从硬件的角度来看，CPU 就是一个`超大规模集成电路`，通过电路实现了加法、乘法乃至各种各样的处理逻辑。

如果我们从软件工程师的角度来讲，CPU 就是一个执行各种`计算机指令`（Instruction Code）的`逻辑机器`。这里的计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作`机器语言`（Machine Language）。

不同的 CPU 能够听懂的语言不太一样。比如，我们的个人电脑用的是 Intel 的 CPU，苹果手机用的是 ARM 的 CPU。这两者能听懂的语言就不太一样。类似这样两种 CPU 各自支持的语言，就是`两组不同的计算机指令集`，英文叫 `Instruction Set`。这里面的“Set”，其实就是数学上的集合，代表不同的单词、语法。

所以，如果我们在自己电脑上写一个程序，然后把这个程序复制一下，装到自己的手机上，肯定是没办法正常运行的，因为这两者语言不通。==而一台电脑上的程序，简单复制一下到另外一台电脑上，通常就能正常运行，因为这两台 CPU 有着相同的指令集，也就是说，它们的语言相通的。==

一个计算机程序，不可能只有一条指令，而是由成千上万条指令组成的。但是 CPU 里不能一直放着所有指令，所以计算机程序平时是存储在存储器中的。`这种程序指令存储在存储器里面的计算机，我们就叫作存储程序型计算机（Stored-program Computer）。`

说到这里，你可能要问了，难道还有不是存储程序型的计算机么？其实，在没有现代计算机之前，有着聪明才智的工程师们，早就发明了一种叫 Plugboard Computer 的计算设备。我把它直译成“插线板计算机”。在一个布满了各种插口和插座的板子上，工程师们用不同的电线来连接不同的插口和插座，从而来完成各种计算任务。下面这个图就是一台 IBM 的 Plugboard，看起来是不是有一股满满的蒸汽朋克范儿？

![image-20230105090957155](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105090957155.png)

#### 1.2从编译到汇编，代码怎么变成机器码？

了解了计算机指令和计算机指令集，接下来我们来看看，平时编写的代码，到底是怎么变成一条条计算机指令，最后被 CPU 执行的呢？我们拿一小段真实的 C 语言程序来看看。

```c
// test.c
int main()
{
  int a = 1; 
  int b = 2;
  a = a + b;
}
```

这是一段再简单不过的 C 语言程序，即便你不了解 C 语言，应该也可以看懂。我们给两个变量 a、b 分别赋值 1、2，然后再将 a、b 两个变量中的值加在一起，重新赋值给了 a 这个变量。

要让这段程序在一个 Linux 操作系统上跑起来，我们需要把整个程序翻译成一个`汇编语言（ASM，Assembly Language）的程序`，这个过程我们一般叫`编译（Compile）成汇编代码`。

针对汇编代码，我们可以再用`汇编器（Assembler）翻译成机器码（Machine Code）`。这些机器码由“0”和“1”组成的机器语言表示。`这一条条机器码，就是一条条的计算机指令。`这样一串串的 16 进制数字，就是我们 CPU 能够真正认识的计算机指令。

在一个 Linux 操作系统上，我们可以简单地使用 gcc 和 objdump 这样两条命令，把对应的汇编代码和机器码都打印出来。

```shell
$ gcc -g -c test.c
$ objdump -d -M intel -S test.o
```

可以看到，左侧有一堆`数字`，这些就是一条条`机器码`；右边有一系列的 `push`、`mov`、`add`、`pop` 等，这些就是对应的`汇编代码`。一行 C 语言代码，有时候只对应一条机器码和汇编代码，有时候则是对应两条机器码和汇编代码。`汇编代码和机器码之间是一一对应的。`

```shell

test.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <main>:
int main()
{
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
  int a = 1; 
   4:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1
  int b = 2;
   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  a = a + b;
  12:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  15:   01 45 fc                add    DWORD PTR [rbp-0x4],eax
}
  18:   5d                      pop    rbp
  19:   c3                      ret    
```

这个时候你可能又要问了，我们实际在用 GCC（GUC 编译器套装，GNU Compiler Collectipon）编译器的时候，可以直接把代码编译成机器码呀，为什么还需要汇编代码呢？原因很简单，你看着那一串数字表示的机器码，是不是摸不着头脑？但是即使你没有学过汇编代码，看的时候多少也能“猜”出一些这些代码的含义。

==因为汇编代码其实就是“给程序员看的机器码”，也正因为这样，机器码和汇编代码是一一对应的。==我们人类很容易记住 add、mov 这些用英文表示的指令，而 8b 45 f8 这样的指令，由于很难一下子看明白是在干什么，所以会非常难以记忆。尽管早年互联网上到处流传，大神程序员着拿小刀在光盘上刻出操作系统的梗，但是要让你用打孔卡来写个程序，估计浪费的卡片比用上的卡片要多得多。

![image-20230105091445224](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105091445224.png)

从高级语言到汇编代码，再到机器码，就是一个日常开发程序，最终变成了 CPU 可以执行的计算机指令的过程。

#### 1.3解析指令和机器码

了解了这个过程，下面我们放大局部，来看看这一行行的汇编代码和机器指令，到底是什么意思。

我们就从平时用的电脑、手机这些设备来说起。这些设备的 CPU 到底有哪些指令呢？这个还真有不少，我们日常用的 Intel CPU，有 2000 条左右的 CPU 指令，实在是太多了，所以我没法一一来给你讲解。不过一般来说，常见的指令可以分成五大类。

第一类是`算术类指令`。我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。

第二类是`数据传输类指令`。给变量赋值、在内存里读写数据，用的都是数据传输类指令。

第三类是`逻辑类指令`。逻辑上的与或非，都是这一类指令。

第四类是`条件分支类指令`。日常我们写的“if/else”，其实都是条件分支类指令。

最后一类是`无条件跳转指令`。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。

你可能一下子记不住，或者对这些指令的含义还不能一下子掌握，这里我画了一个表格，给你举例子说明一下，帮你理解、记忆。

![image-20230105091646476](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105091646476.png)

下面我们来看看，汇编器是怎么把对应的汇编代码，翻译成为机器码的。

我们说过，`不同的 CPU 有不同的指令集，也就对应着不同的汇编语言和不同的机器码`。为了方便你快速理解这个机器码的计算方式，我们选用`最简单的 MIPS 指令集`，来看看机器码是如何生成的。

MIPS 是一组由 MIPS 技术公司在 80 年代中期设计出来的 CPU 指令集。就在最近，MIPS 公司把整个指令集和芯片架构都完全开源了。

![image-20230105091822338](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105091822338.png)

MIPS 的指令是一个 `32` 位的整数，`高 6 位叫操作码（Opcode）`，也就是代表这条指令具体是一条什么样的指令，剩下的 `26` 位有三种格式，分别是 `R、I 和 J`。

`R 指令`是一般用来做算术和逻辑操作，里面有读取和写入数据的寄存器的地址。如果是逻辑位移操作，后面还有位移操作的位移量，而最后的功能码，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令的。

`I 指令`，则通常是用在数据传输、条件分支，以及在运算的时候使用的并非变量还是常数的时候。这个时候，没有了位移量和操作码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或者一个常数。

`J 指令`就是一个跳转指令，高 6 位之外的 26 位都是一个跳转后的地址。

```assembly
add $t0,$s2,$s1
```

我以一个简单的加法算术指令 `add t0,s1, $s2`, 为例，给你解释。为了方便，我们下面都用十进制来表示对应的代码。

> 对应的 MIPS 指令里 opcode 是 0，rs 代表第一个寄存器 s1 的地址是 17，rt 代表第二个寄存器 s2 的地址是 18，rd 代表目标的临时寄存器 t0 的地址，是 8。因为不是位移操作，所以位移量是 0。把这些数字拼在一起，就变成了一个 MIPS 的加法指令。

为了读起来方便，我们一般把对应的二进制数，用 16 进制表示出来。在这里，也就是 0X02324020。这个数字也就是这条指令对应的机器码。

![image-20230105092108142](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105092108142.png)

回到开头我们说的打孔带。如果我们用打孔代表 1，没有打孔代表 0，用 4 行 8 列代表一条指令来打一个穿孔纸带，那么这条命令大概就长这样：

![image-20230105092131572](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105092131572.png)

好了，恭喜你，读到这里，你应该学会了怎么作为人肉编译和汇编器，给纸带打孔编程了，不用再对那些用过打孔卡的前辈们顶礼膜拜了。

#### 1.4总结延伸

到这里，想必你也应该明白了，我们在这一讲的开头介绍的打孔卡，其实就是一种存储程序型计算机。只是这整个程序的机器码，不是通过计算机编译出来的，而是由程序员，用人脑“编译”成一张张卡片的。对应的程序，也不是存储在设备里，而是存储成一张打好孔的卡片。但是整个程序运行的逻辑和其他 CPU 的机器语言没有什么分别，也是处理一串“0”和“1”组成的机器码而已。

这一讲里，我们看到了一个 C 语言程序，是怎么被编译成为汇编语言，乃至通过汇编器再翻译成机器码的。

除了 C 这样的编译型的语言之外，不管是 Python 这样的解释型语言，还是 Java 这样使用虚拟机的语言，其实最终都是由不同形式的程序，把我们写好的代码，转换成 CPU 能够理解的机器码来执行的。

只是解释型语言，是通过解释器在程序运行的时候逐句翻译，而 Java 这样使用虚拟机的语言，则是由虚拟机对编译出来的中间代码进行解释，或者即时编译成为机器码来最终执行。

然而，单单理解一条指令是怎么变成机器码的肯定是不够的。接下来的几节，我会深入讲解，包含条件、循环、函数、递归这些语句的完整程序，是怎么在 CPU 里面执行的。

> 注意：机器码的差异不在于操作系统（也就是不在于Linux/Windows）。而是在于体系结构（Intel X86/ARM/MIPS）。 不同平台的汇编语言也是不同的，所以同样的高级语言编译器在不同的平台上编译出来的代码也是不一样的。

#### 1.5推荐阅读

这一讲里，我们用的是相对最简单的 MIPS 指令集作示例。想要对我们日常使用的 Intel CPU 的指令集有所了解，可以参看《计算机组成与设计：软 / 硬件接口》第 5 版的 2.17 小节。

#### 1.6课后思考

我们把一个数字在命令行里面打印出来，背后对应的机器码是什么？你可以试试通过 GCC 把这个的汇编代码和机器码打出来。

```c
#include<stdio.h>
int main() {
	int a = 10;
	printf("%d", a);
	return 0;
}
```

经过`gcc -g -c test.c和objdump -d -M intel -S test.o`查看对应的汇编和机器码。

```shell
test.o：     文件格式 elf64-x86-64
Disassembly of section .text:
0000000000000000 <main>:
#include<stdio.h>
int main() {
   0:	55                   	push   rbp
   1:	48 89 e5             	mov    rbp,rsp
   4:	48 83 ec 10          	sub    rsp,0x10
	int a = 10;
   8:	c7 45 fc 0a 00 00 00 	mov    DWORD PTR [rbp-0x4],0xa
	printf("%d", a);
   f:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  12:	89 c6                	mov    esi,eax
  14:	bf 00 00 00 00       	mov    edi,0x0
  19:	b8 00 00 00 00       	mov    eax,0x0
  1e:	e8 00 00 00 00       	call   23 <main+0x23>
	return 0;
  23:	b8 00 00 00 00       	mov    eax,0x0
}
  28:	c9                   	leave  
  29:	c3                   	ret
```

### 2.指令跳转：原来if...else就是goto

上一讲，我们讲解了一行代码是怎么变成计算机指令的。你平时写的程序中，肯定不只有 int a = 1 这样最最简单的代码或者指令。我们总是要用到 if…else 这样的条件判断语句、while 和 for 这样的循环语句，还有函数或者过程调用。

对应的，CPU 执行的也不只是一条指令，一般一个程序包含很多条指令。因为有 if…else、for 这样的条件和循环存在，这些指令也不会一路平铺直叙地执行下去。

今天我们就在上一节的基础上来看看，一个计算机程序是怎么被分解成一条条指令来执行的。

#### 2.1CPU 是如何执行指令的？

拿我们用的 Intel CPU 来说，里面差不多有几百亿个晶体管。实际上，一条条计算机指令执行起来非常复杂。好在 CPU 在软件层面已经为我们做好了封装。对于我们这些做软件的程序员来说，我们只要知道，写好的代码变成了指令之后，是`一条一条顺序执行`的就可以了。

我们先不管几百亿的晶体管的背后是怎么通过电路运转起来的，`逻辑上，我们可以认为，CPU 其实就是由一堆寄存器组成的。`而寄存器就是 CPU 内部，由多个触发器（Flip-Flop）或者锁存器（Latches）组成的简单电路。

`触发器和锁存器，其实就是两种不同原理的数字电路组成的逻辑门。`这块内容并不是我们这节课的重点，所以你只要了解就好。如果想要深入学习的话，你可以学习数字电路的相关课程，这里我们不深入探讨。

好了，现在我们接着前面说。`N 个触发器或者锁存器，就可以组成一个 N 位（Bit）的寄存器，能够保存 N 位的数据。`比方说，我们用的 64 位 Intel 服务器，寄存器就是 64 位的。

![image-20230105093256240](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105093256240.png)

一个 CPU 里面会有很多种不同功能的寄存器。我这里给你介绍三种比较特殊的。

一个是 `PC 寄存器（Program Counter Register）`，我们也叫`指令地址寄存器（Instruction Address Register）`。顾名思义，它就是用来存放下一条需要执行的计算机指令的内存地址。

第二个是`指令寄存器（Instruction Register）`，用来存放当前正在执行的指令。

第三个是`条件码寄存器（Status Register）`，用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。

除了这些特殊的寄存器，CPU 里面还有更多用来存储数据和内存地址的寄存器。这样的寄存器通常一类里面不止一个。我们通常根据存放的数据内容来给它们取名字，比如整数寄存器、浮点数寄存器、向量寄存器和地址寄存器等等。有些寄存器既可以存放数据，又能存放地址，我们就叫它通用寄存器。

![image-20230105093426501](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105093426501.png)

==实际上，一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。==

而有些特殊指令，比如上一讲我们讲到 J 类指令，也就是跳转指令，会修改 PC 寄存器里面的地址值。这样，下一条要执行的指令就不是从内存里面顺序加载的了。`事实上，这些跳转指令的存在，也是我们可以在写程序的时候，使用 if…else 条件语句和 while/for 循环语句的原因。`

#### 2.2从 if…else 来看程序的执行和跳转

我们现在就来看一个包含 if…else 的简单程序。

```c
// test.c

#include <time.h>
#include <stdlib.h>

int main()
{
  srand(time(NULL));
  int r = rand() % 2;
  int a = 10;
  if (r == 0)
  {
    a = 1;
  } else {
    a = 2;
  } 
```

我们用 rand 生成了一个随机数 r，r 要么是 0，要么是 1。当 r 是 0 的时候，我们把之前定义的变量 a 设成 1，不然就设成 2。

```shell
$ gcc -g -c test.c
$ objdump -d -M intel -S test.o 
```

我们把这个程序编译成汇编代码。你可以忽略前后无关的代码，只关注于这里的 if…else 条件判断语句。对应的汇编代码是这样的：

```shell

    if (r == 0)
  3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0
  3f:   75 09                   jne    4a <main+0x4a>
    {
        a = 1;
  41:   c7 45 f8 01 00 00 00    mov    DWORD PTR [rbp-0x8],0x1
  48:   eb 07                   jmp    51 <main+0x51>
    }
    else
    {
        a = 2;
  4a:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  51:   b8 00 00 00 00          mov    eax,0x0
    } 
```

可以看到，这里对于 r == 0 的条件判断，被编译成了 cmp 和 jne 这两条指令。

`cmp` 指令比较了前后两个操作数的值，这里的 `DWORD PTR 代表操作的数据类型是 32 位的整数`，而`[rbp-0x4]则是变量 r 的内存地址`。所以，第一个操作数就是从内存里拿到的变量 r 的值。`第二个操作数 0x0 就是我们设定的常量 0 的 16 进制表示`。cmp 指令的比较结果，会存入到条件码寄存器当中去。

在这里，如果比较的结果是 True，也就是 r == 0，就把`零标志条件码`（对应的条件码是 ZF，Zero Flag）设置为 1。除了零标志之外，Intel 的 CPU 下还有进位标志（CF，Carry Flag）、符号标志（SF，Sign Flag）以及溢出标志（OF，Overflow Flag），用在不同的判断条件下。

cmp 指令执行完成之后，PC 寄存器会自动自增，开始执行下一条 jne 的指令。

跟着的` jne `指令，是 `jump if not equal` 的意思，它会查看对应的零标志位。如果 ZF 为 1，说明上面的比较结果是 TRUE，如果是 ZF 是 0，也就是上面的比较结果是 False，会跳转到后面跟着的操作数 4a 的位置。这个 4a，对应这里汇编代码的行号，也就是上面设置的 else 条件里的第一条指令。当跳转发生的时候，PC 寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的 4a 这个地址。这个时候，CPU 再把 4a 地址里的指令加载到指令寄存器中来执行。

跳转到执行地址为 4a 的指令，实际是一条 mov 指令，第一个操作数和前面的 cmp 指令一样，是另一个 32 位整型的内存地址，以及 2 的对应的 16 进制值 0x2。mov 指令把 2 设置到对应的内存里去，相当于一个赋值操作。然后，PC 寄存器里的值继续自增，执行下一条 mov 指令。

这条 mov 指令的第一个操作数 eax，代表累加寄存器，第二个操作数 0x0 则是 16 进制的 0 的表示。这条指令其实没有实际的作用，它的作用是一个占位符。我们回过头去看前面的 if 条件，如果满足的话，在赋值的 mov 指令执行完成之后，有一个 jmp 的无条件跳转指令。跳转的地址就是这一行的地址 51。==我们的 main 函数没有设定返回值，而 mov eax, 0x0 其实就是给 main 函数生成了一个默认的为 0 的返回值到累加器里面。if 条件里面的内容执行完成之后也会跳转到这里，和 else 里的内容结束之后的位置是一样的。==

![image-20230105094032653](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105094032653.png)

上一讲我们讲打孔卡的时候说到，读取打孔卡的机器会顺序地一段一段地读取指令，然后执行。执行完一条指令，它会自动地顺序读取下一条指令。如果执行的当前指令带有跳转的地址，比如往后跳 10 个指令，那么机器会自动将卡片带往后移动 10 个指令的位置，再来执行指令。同样的，机器也能向前移动，去读取之前已经执行过的指令。这也就是我们的 while/for 循环实现的原理。

#### 2.3如何通过 if…else 和 goto 来实现循环？

```c
int main()
{
    int a = 0;
    for (int i = 0; i < 3; i++)
    {
        a += i;
    }
}
```

我们再看一段简单的利用 for 循环的程序。我们循环自增变量 i 三次，三次之后，i>=3，就会跳出循环。整个程序，对应的 Intel 汇编代码就是这样的：

```shell

    for (int i = 0; i <= 2; i++)
   b:   c7 45 f8 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0
  12:   eb 0a                   jmp    1e 
    {
        a += i;
  14:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x4]
  17:   01 45 fc                add    DWORD PTR [rbp-0x8],eax

  1a:   83 45 f8 01             add    DWORD PTR [rbp-0x4],0x1
  1e:   83 7d f8 02             cmp    DWORD PTR [rbp-0x4],0x2
  22:   7e f0                   jle    14 
  24:   b8 00 00 00 00          mov    eax,0x0
    }
```

`可以看到，对应的循环也是用 1e 这个地址上的 cmp 比较指令，和紧接着的 jle 条件跳转指令来实现的。`主要的差别在于，这里的 jle 跳转的地址，在这条指令之前的地址 14，而非 if…else 编译出来的跳转指令之后。往前跳转使得条件满足的时候，PC 寄存器会把指令地址设置到之前执行过的指令位置，重新执行之前执行过的指令，直到条件不满足，顺序往下执行 jle 之后的指令，整个循环才结束。

![image-20230105094304609](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105094304609.png)

如果你看一长条打孔卡的话，就会看到卡片往后移动一段，执行了之后，又反向移动，去重新执行前面的指令。

其实，你有没有觉得，jle 和 jmp 指令，有点像程序语言里面的 goto 命令，直接指定了一个特定条件下的跳转位置。`虽然我们在用高级语言开发程序的时候反对使用 goto，但是实际在机器指令层面，无论是 if…else…也好，还是 for/while 也好，都是用和 goto 相同的跳转到特定指令位置的方式来实现的。`

#### 2.4总结延伸

这一节，我们在单条指令的基础上，学习了程序里的多条指令，究竟是怎么样一条一条被执行的。`除了简单地通过 PC 寄存器自增的方式顺序执行外，条件码寄存器会记录下当前执行指令的条件判断状态，然后通过跳转指令读取对应的条件码，修改 PC 寄存器内的下一条指令的地址，最终实现 if…else 以及 for/while 这样的程序控制流程。`

你会发现，虽然我们可以用高级语言，可以用不同的语法，比如 if…else 这样的条件分支，或者 while/for 这样的循环方式，来实现不同的程序运行流程，但是回归到计算机可以识别的机器指令级别，其实都只是一个简单的地址跳转而已，也就是一个类似于 goto 的语句。

==想要在硬件层面实现这个 goto 语句，除了本身需要用来保存下一条指令地址，以及当前正要执行指令的 PC 寄存器、指令寄存器外，我们只需要再增加一个条件码寄存器，来保留条件判断的状态。这样简简单单的三个寄存器，就可以实现条件判断和循环重复执行代码的功能。==

下一节，我们会进一步讲解，如果程序中出现函数或者过程这样可以复用的代码模块，对应的指令是怎么样执行的，会和我们这里的 if…else 有什么不同。

#### 2.5推荐阅读

《深入理解计算机系统》的第 3 章，详细讲解了 C 语言和 Intel CPU 的汇编语言以及指令的对应关系，以及 Intel CPU 的各种寄存器和指令集。

Intel 指令集相对于之前的 MIPS 指令集要复杂一些，一方面，所有的指令是变长的，从 1 个字节到 15 个字节不等；另一方面，即使是汇编代码，还有很多针对操作数据的长度不同有不同的后缀。我在这里没有详细解释各个指令的含义，如果你对用 C/C++ 做 Linux 系统层面开发感兴趣，建议你一定好好读一读这一章节。

#### 2.6课后思考

除了 if…else 的条件语句和 for/while 的循环之外，大部分编程语言还有 switch…case 这样的条件跳转语句。switch…case 编译出来的汇编代码也是这样使用 jne 指令进行跳转吗？对应的汇编代码的性能和写很多 if…else 有什么区别呢？你可以试着写一个简单的 C 语言程序，编译成汇编代码看一看。

```c
#include<stdio.h>
#include<stdlib.h>
int main() {
	srand(time(NULL));
	int r = rand() % 3;
	int a = 0;
	switch(r){
	    case 2:
		a = 2;
		break;
	    case 1:
		a = 1;
		break;
	    case 0:
		a = 0;
		break;
	    default:
		a = -1;
	}
	return 0;
}
```

经过`gcc -g -c test.c和objdump -d -M intel -S test.o`查看对应的汇编和机器码。

```shell
test.o：     文件格式 elf64-x86-64
Disassembly of section .text:
0000000000000000 <main>:
#include<stdio.h>
#include<stdlib.h>
int main() {
   0:	55                   	push   rbp
   1:	48 89 e5             	mov    rbp,rsp
   4:	48 83 ec 10          	sub    rsp,0x10
	srand(time(NULL));
   8:	bf 00 00 00 00       	mov    edi,0x0
   d:	b8 00 00 00 00       	mov    eax,0x0
  12:	e8 00 00 00 00       	call   17 <main+0x17>
  17:	89 c7                	mov    edi,eax
  19:	e8 00 00 00 00       	call   1e <main+0x1e>
	int r = rand() % 3;
  1e:	e8 00 00 00 00       	call   23 <main+0x23>
  23:	89 c1                	mov    ecx,eax
  25:	ba 56 55 55 55       	mov    edx,0x55555556
  2a:	89 c8                	mov    eax,ecx
  2c:	f7 ea                	imul   edx
  2e:	89 c8                	mov    eax,ecx
  30:	c1 f8 1f             	sar    eax,0x1f
  33:	29 c2                	sub    edx,eax
  35:	89 d0                	mov    eax,edx
  37:	89 45 fc             	mov    DWORD PTR [rbp-0x4],eax
  3a:	8b 55 fc             	mov    edx,DWORD PTR [rbp-0x4]
  3d:	89 d0                	mov    eax,edx
  3f:	01 c0                	add    eax,eax
  41:	01 d0                	add    eax,edx
  43:	29 c1                	sub    ecx,eax
  45:	89 c8                	mov    eax,ecx
  47:	89 45 fc             	mov    DWORD PTR [rbp-0x4],eax
	int a = 0;
  4a:	c7 45 f8 00 00 00 00 	mov    DWORD PTR [rbp-0x8],0x0
	switch(r){
  51:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  54:	83 f8 01             	cmp    eax,0x1
  57:	74 14                	je     6d <main+0x6d>
  59:	83 f8 02             	cmp    eax,0x2
  5c:	74 06                	je     64 <main+0x64>
  5e:	85 c0                	test   eax,eax
  60:	74 14                	je     76 <main+0x76>
  62:	eb 1b                	jmp    7f <main+0x7f>
	    case 2:
		a = 2;
  64:	c7 45 f8 02 00 00 00 	mov    DWORD PTR [rbp-0x8],0x2
		break;
  6b:	eb 19                	jmp    86 <main+0x86>
	    case 1:
		a = 1;
  6d:	c7 45 f8 01 00 00 00 	mov    DWORD PTR [rbp-0x8],0x1
		break;
  74:	eb 10                	jmp    86 <main+0x86>
	    case 0:
		a = 0;
  76:	c7 45 f8 00 00 00 00 	mov    DWORD PTR [rbp-0x8],0x0
		break;
  7d:	eb 07                	jmp    86 <main+0x86>
	    default:
		a = -1;
  7f:	c7 45 f8 ff ff ff ff 	mov    DWORD PTR [rbp-0x8],0xffffffff
	}
	return 0;
  86:	b8 00 00 00 00       	mov    eax,0x0
}
  8b:	c9                   	leave  
  8c:	c3                   	ret
```

为什么这次jne 指令是16位，mov指令是40位？

> 上一讲里面，我们是拿MIPS这样比较简单的指令集来举例子的，里面的指令都是等长的。 这一讲里面，实际是在一台Intel CPU的Linux机器上的程序，Intel的指令集里面的每条指令的长度并不是都相等的。

**标准答案：**

##### 2.6.1switch...case与if...else的根本区别

switch...case会`生成一个跳转表来指示实际的case分支的地址，而这个跳转表的索引号与switch变量的值是相等的`。从而，switch...case不用像if...else那样遍历条件分支直到命中条件，而`只需访问对应索引号的表项从而到达定位分支的目的`。

具体地说，switch...case会生成一份大小（表项数）为最大case常量＋1的跳表，程序首先判断switch变量是否大于最大case 常量，若大于，则跳到default分支处理；否则取得索引号为switch变量大小的跳表项的地址（即跳表的起始地址＋表项大小*索引号），程序接着跳到此地址执行，到此完成了分支的跳转。

##### 2.6.2第一步，写一个demo程序：foo.c

```c
#include <stdio.h>

static int
foo_ifelse(char c)
{
        if (c == '0' || c == '1') {
                c += 1;
        } else if (c == 'a' || c == 'b') {
                c += 2;
        } else if (c == 'A' || c == 'B') {
                c += 3;
        } else {
                c += 4;
        }

        return (c);
}

static int
foo_switch(char c)
{
        switch (c) {
                case '1':
                case '0': c += 1; break;
                case 'b':
                case 'a': c += 2; break;
                case 'B':
                case 'A': c += 3; break;
                default:  c += 4; break;
        }

        return (c);
}

int
main(int argc, char **argv)
{
        int m1 = foo_ifelse('0');
        int m2 = foo_ifelse('1');
        int n1 = foo_switch('a');
        int n2 = foo_switch('b');
        (void) printf("%c %c %c %c\n", m1, m2, n1, n2);
        return (0);
}
```

##### 2.6.3第二步，在Ubuntu上使用gcc编译

```shell
$ gcc -g -o foo foo.c
```

##### 2.6.4第三步，使用gdb对二进制文件foo反汇编 (使用intel语法)

```assembly
反汇编foo_ifelse（）
(gdb) set disassembly-flavor intel
(gdb) disas /m foo_ifelse
Dump of assembler code for function foo_ifelse:
       {
   0x0804841d <+0>:     push   ebp
   0x0804841e <+1>:     mov    ebp,esp
   0x08048420 <+3>:     sub    esp,0x4#扩展函数栈
   0x08048423 <+6>:     mov    eax,DWORD PTR [ebp+0x8]#ebp+0x8地址处存放函数的参数，ebp+0x4存放上级函数的返回地址
   0x08048426 <+9>:     mov    BYTE PTR [ebp-0x4],al#ebp-0x4是函数栈上的形参位置，因为参数是char类型，所以按照BYTE操作，取eax的低八位

               if (c == '0' || c == '1') {
   0x08048429 <+12>:    cmp    BYTE PTR [ebp-0x4],0x30
   0x0804842d <+16>:    je     0x8048435 <foo_ifelse+24>#条件为真跳转至if内语句
   0x0804842f <+18>:    cmp    BYTE PTR [ebp-0x4],0x31
   0x08048433 <+22>:    jne    0x8048441 <foo_ifelse+36>#条件为假跳转至下一个if语句
                       c += 1;
   0x08048435 <+24>:    movzx  eax,BYTE PTR [ebp-0x4]
   0x08048439 <+28>:    add    eax,0x1
   0x0804843c <+31>:    mov    BYTE PTR [ebp-0x4],al
   0x0804843f <+34>:    jmp    0x804847b <foo_ifelse+94>

               } else if (c == 'a' || c == 'b') {
   0x08048441 <+36>:    cmp    BYTE PTR [ebp-0x4],0x61
   0x08048445 <+40>:    je     0x804844d <foo_ifelse+48>
   0x08048447 <+42>:    cmp    BYTE PTR [ebp-0x4],0x62
   0x0804844b <+46>:    jne    0x8048459 <foo_ifelse+60>

                       c += 2;
   0x0804844d <+48>:    movzx  eax,BYTE PTR [ebp-0x4]
   0x08048451 <+52>:    add    eax,0x2
   0x08048454 <+55>:    mov    BYTE PTR [ebp-0x4],al
   0x08048457 <+58>:    jmp    0x804847b <foo_ifelse+94>

               } else if (c == 'A' || c == 'B') {
   0x08048459 <+60>:    cmp    BYTE PTR [ebp-0x4],0x41
   0x0804845d <+64>:    je     0x8048465 <foo_ifelse+72>
   0x0804845f <+66>:    cmp    BYTE PTR [ebp-0x4],0x42
   0x08048463 <+70>:    jne    0x8048471 <foo_ifelse+84>

                      c += 3;
   0x08048465 <+72>:    movzx  eax,BYTE PTR [ebp-0x4]
   0x08048469 <+76>:    add    eax,0x3
   0x0804846c <+79>:    mov    BYTE PTR [ebp-0x4],al
   0x0804846f <+82>:    jmp    0x804847b <foo_ifelse+94>

              } else {
                      c += 4;
   0x08048471 <+84>:    movzx  eax,BYTE PTR [ebp-0x4]
   0x08048475 <+88>:    add    eax,0x4
   0x08048478 <+91>:    mov    BYTE PTR [ebp-0x4],al

              }
              return (c);
   0x0804847b <+94>:    movsx  eax,BYTE PTR [ebp-0x4]#函数调用约定eax存放函数的结果

      }
   0x0804847f <+98>:    leave
   0x08048480 <+99>:    ret

End of assembler dump.
(gdb)

(gdb) set disassembly-flavor intel
(gdb) disas /m foo_switch
Dump of assembler code for function foo_switch:
      {
   0x08048481 <+0>:     push   ebp
   0x08048482 <+1>:     mov    ebp,esp
   0x08048484 <+3>:     sub    esp,0x4
   0x08048487 <+6>:     mov    eax,DWORD PTR [ebp+0x8]
   0x0804848a <+9>:     mov    BYTE PTR [ebp-0x4],al

              switch (c) {
   0x0804848d <+12>:    movsx  eax,BYTE PTR [ebp-0x4]
   0x08048491 <+16>:    sub    eax,0x30#判断量减去case最小常量'0'得到索引号
   0x08048494 <+19>:    cmp    eax,0x32#索引号与case最大常量'b'比较，过大直接跳转到default部分
   0x08048497 <+22>:    ja     0x80484c6 <foo_switch+69>
   0x08048499 <+24>:    mov    eax,DWORD PTR [eax*4+0x80485f0]#根据索引表按照索引号跳转至指定位置
   0x080484a0 <+31>:    jmp    eax

                      case '1':
                      case '0': c += 1; break;
   0x080484a2 <+33>:    movzx  eax,BYTE PTR [ebp-0x4]
   0x080484a6 <+37>:    add    eax,0x1
   0x080484a9 <+40>:    mov    BYTE PTR [ebp-0x4],al
   0x080484ac <+43>:    jmp    0x80484d1 <foo_switch+80>#break跳出switch循环

                      case 'b':
                      case 'a': c += 2; break;
   0x080484ae <+45>:    movzx  eax,BYTE PTR [ebp-0x4]
   0x080484b2 <+49>:    add    eax,0x2
   0x080484b5 <+52>:    mov    BYTE PTR [ebp-0x4],al
   0x080484b8 <+55>:    jmp    0x80484d1 <foo_switch+80>

                      case 'B':
                      case 'A': c += 3; break;
   0x080484ba <+57>:    movzx  eax,BYTE PTR [ebp-0x4]
   0x080484be <+61>:    add    eax,0x3
   0x080484c1 <+64>:    mov    BYTE PTR [ebp-0x4],al
   0x080484c4 <+67>:    jmp    0x80484d1 <foo_switch+80>

                      default:  c += 4; break;
   0x080484c6 <+69>:    movzx  eax,BYTE PTR [ebp-0x4]
   0x080484ca <+73>:    add    eax,0x4
   0x080484cd <+76>:    mov    BYTE PTR [ebp-0x4],al
   0x080484d0 <+79>:    nop

              }

              return (c);
   0x080484d1 <+80>:    movsx  eax,BYTE PTR [ebp-0x4]

      }
   0x080484d5 <+84>:    leave
   0x080484d6 <+85>:    ret

End of assembler dump.
(gdb)
```

**分析**

1. 在foo_ifelse()中，采用的方法是按顺序比较，如满足条件，则执行对应的代码，否则跳转到下一个分支再进行比较；
2. 在foo_switch()中，下面的这段汇编代码比较有意思:

```assembly
switch (c) {
   0x0804848d <+12>:    movsx  eax,BYTE PTR [ebp-0x4]
   0x08048491 <+16>:    sub    eax,0x30
   0x08048494 <+19>:    cmp    eax,0x32
   0x08048497 <+22>:    ja     0x80484c6 <foo_switch+69>
   0x08048499 <+24>:    mov    eax,DWORD PTR [eax*4+0x80485f0]
   0x080484a0 <+31>:    jmp    eax
```

第17行 jmp eax

也就是说，当c的取值不同，是什么机制保证第17行能跳转到正确的位置开始执行呢？

第16行: eax = [eax * 4 + 0x80485f0]

搞清楚了从地址0x80485f0开始，对应的内存里面的内容也就回答了刚才的问题。

**执行完第16行后，**

- 当c为'1'或'0'时， eax的值应该是0x080484a2；
- 当c为'b'或'a'时， eax的值应该是0x080484ae；
- 当c为'B'或'A'时， eax的值应该是0x080484ba；

通过gdb查看对应的内存，确实如此！

```shell
>>> ord('1') - 0x30
>>> ord('0') - 0x30
(gdb) x /2wx  0*4+0x80485f0
0x80485f0:    0x080484a2    0x080484a2

>>> ord('b') - 0x30
>>> ord('a') - 0x30
(gdb) x /2wx 49*4+0x80485f0
0x80486b4:    0x080484ae    0x080484ae
                
>>> ord('B') - 0x30
>>> ord('A') - 0x30
(gdb) x /2wx 17*4+0x80485f0
0x8048634:    0x080484ba    0x080484ba
```

那么，我们可以大胆的猜测，虽然c的取值不同但是跳转的IP确实是精准无误的，一定是编译阶段就被设定好了，果真如此吗？接下来分析一下对应的二进制文件foo。

##### 2.6.5第四步，使用objdump查看foo

```shell
$ objdump -D foo > /tmp/x
 
$ vim /tmp/x
 509 Disassembly of section .rodata:
 ...
 518  80485f0:       a2 84 04 08 a2          mov    %al,0xa2080484
 519  80485f5:       84 04 08                test   %al,(%eax,%ecx,1)
 ...
 534  8048630:       c6 84 04 08 ba 84 04    movb   $0x8,0x484ba08(%esp,%eax,1)
 535  8048637:       08
 536  8048638:       ba 84 04 08 c6          mov    $0xc6080484,%edx
 ...
 566  80486b0:       c6 84 04 08 ae 84 04    movb   $0x8,0x484ae08(%esp,%eax,1)
 567  80486b7:       08
 568  80486b8:       ae                      scas   %es:(%edi),%al
 569  80486b9:       84 04 08                test   %al,(%eax,%ecx,1)
 ...
```

在0x80485f0地址，存的8个字节正好是0x080484a2, 0x080484a2 (注意：按照小端的方式阅读)

在0x80486b4地址，存的8个字节正好是0x080484ae, 0x080484ae

在0x8048634地址，存的8个字节正好是0x080484ba,0x080484ba

果然不出所料，要跳转的IP的值正是在编译的时候存入了.rodata（只读数据区）。一旦foo开始运行，对应的内存地址就填写上了正确的待跳转地址，接下来只不过是根据c的取值计算出对应的IP存放的内存起始地址X，从X中取出待跳转的地址，直接跳转就好。

```assembly
16    0x08048499 <+24>:    mov    eax,DWORD PTR [eax*4+0x80485f0]
17    0x080484a0 <+31>:    jmp    eax
```

到此为止，我们已经搞清楚了为什么switch...case...语句相对于if...else if...else...来说执行效率要高的根本原因。简言之，编译的时候创建了一个map存于.rodata区中，运行的时候直接根据输入(c的值）查表，找到对应的IP后直接跳转。（省去了cmp, jmp -> cmp, jmp -> cmp, jmp...这一冗长的计算过程。）

> switch...case...执行效率高，属于典型的以空间换时间。

### 3.函数调用：为什么会发生stack overflow？

今天，我们就从程序的函数调用开始，讲讲函数间的相互调用，在计算机指令层面是怎么实现的，以及什么情况下会发生栈溢出这个错误。

#### 3.1为什么我们需要程序栈？

和前面几讲一样，我们还是从一个非常简单的 C 程序 function_example.c 看起。

```c
// function_example.c
#include <stdio.h>
int static add(int a, int b)
{
    return a+b;
}


int main()
{
    int x = 5;
    int y = 10;
    int u = add(x, y);
}
```

这个程序定义了一个简单的函数 add，接受两个参数 a 和 b，返回值就是 a+b。而 main 函数里则定义了两个变量 x 和 y，然后通过调用这个 add 函数，来计算 u=x+y，最后把 u 的数值打印出来。

```shell
$ gcc -g -c function_example.c
$ objdump -d -M intel -S function_example.o
```

我们把这个程序编译之后，objdump 出来。我们来看一看对应的汇编代码。

```shell

int static add(int a, int b)
{
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
   4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
   7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi
    return a+b;
   a:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
   d:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  10:   01 d0                   add    eax,edx
}
  12:   5d                      pop    rbp
  13:   c3                      ret    
0000000000000014 <main>:
int main()
{
  14:   55                      push   rbp
  15:   48 89 e5                mov    rbp,rsp
  18:   48 83 ec 10             sub    rsp,0x10
    int x = 5;
  1c:   c7 45 fc 05 00 00 00    mov    DWORD PTR [rbp-0x4],0x5
    int y = 10;
  23:   c7 45 f8 0a 00 00 00    mov    DWORD PTR [rbp-0x8],0xa
    int u = add(x, y);
  2a:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]
  2d:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
  30:   89 d6                   mov    esi,edx
  32:   89 c7                   mov    edi,eax
  34:   e8 c7 ff ff ff          call   0 <add>
  39:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
  3c:   b8 00 00 00 00          mov    eax,0x0
}
  41:   c9                      leave  
  42:   c3                      ret    
```

可以看出来，在这段代码里，main 函数和上一节我们讲的的程序执行区别并不大，它主要是把 jump 指令换成了函数调用的 call 指令。`call 指令后面跟着的，仍然是跳转后的程序地址。`

这些你理解起来应该不成问题。我们下面来看一个有意思的部分。

我们来看 add 函数。可以看到，add 函数编译之后，代码先执行了一条 push 指令和一条 mov 指令；在函数执行结束的时候，又执行了一条 pop 和一条 ret 指令。这四条指令的执行，其实就是在进行我们接下来要讲`压栈（Push）`和`出栈（Pop）`操作。

你有没有发现，函数调用和上一节我们讲的 if…else 和 for/while 循环有点像。它们两个都是在原来顺序执行的指令过程里，执行了一个内存地址的跳转指令，让指令从原来顺序执行的过程里跳开，从新的跳转后的位置开始执行。

`但是，这两个跳转有个区别，if…else 和 for/while 的跳转，是跳转走了就不再回来了，就在跳转后的新地址开始顺序地执行指令`，就好像徐志摩在《再别康桥》里面写的：“我挥一挥衣袖，不带走一片云彩”，继续进行新的生活了。`而函数调用的跳转，在对应函数的指令执行完了之后，还要再回到函数调用的地方，继续执行 call 之后的指令`，就好像贺知章在《回乡偶书》里面写的那样：“少小离家老大回，乡音未改鬓毛衰”，不管走多远，最终还是要回来。

那我们有没有一个可以不跳转回到原来开始的地方，来实现函数的调用呢？直觉上似乎有这么一个解决办法。`你可以把调用的函数指令，直接插入在调用函数的地方，替换掉对应的 call 指令，然后在编译器编译代码的时候，直接就把函数调用变成对应的指令替换掉。`

不过，仔细琢磨一下，你会发现这个方法有些问题。如果函数 A 调用了函数 B，然后函数 B 再调用函数 A，我们就得面临在 A 里面插入 B 的指令，然后在 B 里面插入 A 的指令，这样就会产生无穷无尽地替换。就好像两面镜子面对面放在一块儿，任何一面镜子里面都会看到无穷多面镜子。

![image-20230105101619201](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105101619201.png)

看来，把被调用函数的指令直接插入在调用处的方法行不通。那我们就换一个思路，`能不能把后面要跳回来执行的指令地址给记录下来呢`？就像前面讲 PC 寄存器一样，我们可以专门设立一个“程序调用寄存器”，来存储接下来要跳转回来执行的指令地址。等到函数调用结束，从这个寄存器里取出地址，再跳转到这个记录的地址，继续执行就好了。

但是在多层函数调用里，简单只记录一个地址也是不够的。我们在调用函数 A 之后，A 还可以调用函数 B，B 还能调用函数 C。这一层又一层的调用并没有数量上的限制。`在所有函数调用返回之前，每一次调用的返回地址都要记录下来，但是我们 CPU 里的寄存器数量并不多。`像我们一般使用的 Intel i7 CPU 只有 16 个 64 位寄存器，调用的层数一多就存不下了。

最终，计算机科学家们想到了一个比单独记录跳转回来的地址更完善的办法。我们在内存里面开辟一段空间，用栈这个后进先出（LIFO，Last In First Out）的数据结构。==栈就像一个乒乓球桶，每次程序调用函数之前，我们都把调用返回后的地址写在一个乒乓球上，然后塞进这个球桶。这个操作其实就是我们常说的压栈。如果函数执行完了，我们就从球桶里取出最上面的那个乒乓球，很显然，这就是出栈。==

`拿到出栈的乒乓球，找到上面的地址，把程序跳转过去，就返回到了函数调用后的下一条指令了。`如果函数 A 在执行完成之前又调用了函数 B，那么在取出乒乓球之前，我们需要往球桶里塞一个乒乓球。而我们从球桶最上面拿乒乓球的时候，拿的也一定是最近一次的，也就是最下面一层的函数调用完成后的地址。乒乓球桶的底部，就是栈底，最上面的乒乓球所在的位置，就是栈顶。

![image-20230105101817560](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105101817560.png)

`在真实的程序里，压栈的不只有函数调用完成后的返回地址。比如函数 A 在调用 B 的时候，需要传输一些参数数据，这些参数数据在寄存器不够用的时候也会被压入栈中。整个函数 A 所占用的所有内存空间，就是函数 A 的栈帧（Stack Frame）。`

而实际的程序栈布局，顶和底与我们的乒乓球桶相比是倒过来的。底在最上面，顶在最下面，这样的布局是因为栈底的内存地址是在一开始就固定的。`而一层层压栈之后，栈顶的内存地址是在逐渐变小而不是变大。`

![image-20230105101912678](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105101912678.png)

图中，`rbp` 是 register base pointer `栈基址寄存器`（栈帧指针），指向`当前栈帧的栈底地址`。`rsp` 是 register stack pointer `栈顶寄存器`（栈指针），指向`栈顶元素`。

对应上面函数 add 的汇编代码，我们来仔细看看，main 函数调用 add 函数时，add 函数入口在 0～1 行，add 函数结束之后在 12～13 行。

> 我们在调用第 34 行的 call 指令时，会把当前的 PC 寄存器里的下一条指令的地址压栈，保留函数调用结束后要执行的指令地址。而 add 函数的第 0 行，push rbp 这个指令，就是在进行压栈。这里的 rbp 又叫栈帧指针（Frame Pointer），是一个存放了当前栈帧位置的寄存器。push rbp 就把之前调用函数，也就是 main 函数的栈帧的栈底地址，压到栈顶。
>
> 接着，第 1 行的一条命令 mov rbp, rsp 里，则是把 rsp 这个栈指针（Stack Pointer）的值复制到 rbp 里，而 rsp 始终会指向栈顶。这个命令意味着，rbp 这个栈帧指针指向的地址，变成当前最新的栈顶，也就是 add 函数的栈帧的栈底地址了。
>
> 而在函数 add 执行完成之后，又会分别调用第 12 行的 pop rbp 来将当前的栈顶出栈，这部分操作维护好了我们整个栈帧。然后，我们可以调用第 13 行的 ret 指令，这时候同时要把 call 调用的时候压入的 PC 寄存器里的下一条指令出栈，更新到 PC 寄存器中，将程序的控制权返回到出栈后的栈顶。

==call 在调用的时候会做push eip的操作，而在ret的时候会做pop eip的操作。==

> 指令地址本身的压栈和出栈是在 call 和 ret 的部分进行的。 你可以认为 call 的同时进行了一次 push rip 把PC寄存器里面的内容压栈了，而在 ret 的时候 pop 把这部分数据出栈写回到PC寄存器里面了。

#### 3.2如何构造一个 stack overflow？

通过引入栈，我们可以看到，无论有多少层的函数调用，或者在函数 A 里调用函数 B，再在函数 B 里调用 A，这样的递归调用，我们都只需要通过维持 rbp 和 rsp，这两个维护栈顶所在地址的寄存器，就能管理好不同函数之间的跳转。不过，栈的大小也是有限的。如果函数调用层数太多，我们往栈里压入它存不下的内容，程序在执行的过程中就会遇到栈溢出的错误，这就是大名鼎鼎的“stack overflow”。

要构造一个栈溢出的错误并不困难，最简单的办法，就是我们上面说的 Infiinite Mirror Effect 的方式，让函数 A 调用自己，并且不设任何终止条件。这样一个无限递归的程序，在不断地压栈过程中，将整个栈空间填满，并最终遇上 stack overflow。

```c
int a()
{
  return a();
}


int main()
{
  a();
  return 0;
}
```

除了无限递归，递归层数过深，在栈空间里面创建非常占内存的变量（比如一个巨大的数组），这些情况都很可能给你带来 stack overflow。相信你理解了栈在程序运行的过程里面是怎么回事，未来在遇到 stackoverflow 这个错误的时候，不会完全没有方向了。

#### 3.3如何利用函数内联进行性能优化？

上面我们提到一个方法，把一个实际调用的函数产生的指令，直接插入到的位置，来替换对应的函数调用指令。尽管这个通用的函数调用方案，被我们否决了，但是如果被调用的函数里，没有调用其他函数，这个方法还是可以行得通的。

==事实上，这就是一个常见的编译器进行自动优化的场景，我们通常叫函数内联（Inline）。==我们只要在 GCC 编译的时候，加上对应的一个让编译器自动优化的参数 -O，编译器就会在可行的情况下，进行这样的指令替换。

我们来看一段代码。

```c

#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int static add(int a, int b)
{
    return a+b;
}

int main()
{
    srand(time(NULL));
    int x = rand() % 5
    int y = rand() % 10;
    int u = add(x, y)
    printf("u = %d\n", u)
}
```

为了避免编译器优化掉太多代码，我小小修改了一下 function_example.c，让参数 x 和 y 都变成了，通过随机数生成，并在代码的最后加上将 u 通过 printf 打印出来的语句。

```shell
$ gcc -g -c -O function_example_inline.c
$ objdump -d -M intel -S function_example_inline.o
```

上面的 function_example_inline.c 的编译出来的汇编代码，没有把 add 函数单独编译成一段指令顺序，而是在调用 u = add(x, y) 的时候，直接替换成了一个 add 指令。

```shell
    return a+b;
  4c:   01 de                   add    esi,ebx
```

==除了依靠编译器的自动优化，你还可以在定义函数的地方，加上 inline 的关键字，来提示编译器对函数进行内联。==

==内联带来的优化是，CPU 需要执行的指令数变少了，根据地址跳转的过程不需要了，压栈和出栈的过程也不用了。==

不过内联并不是没有代价，内联意味着，我们把可以复用的程序指令在调用它的地方完全展开了。`如果一个函数在很多地方都被调用了，那么就会展开很多次，整个程序占用的空间就会变大了。`

![image-20230105102505577](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105102505577.png)

这样没有调用其他函数，只会被调用的函数，我们一般称之为叶子函数（或叶子过程）。

#### 3.4总结延伸

这一节，我们讲了一个程序的函数间调用，在 CPU 指令层面是怎么执行的。其中一定需要你牢记的，就是程序栈这个新概念。

我们可以方便地通过压栈和出栈操作，使得程序在不同的函数调用过程中进行转移。而函数内联和栈溢出，一个是我们常常可以选择的优化方案，另一个则是我们会常遇到的程序 Bug。

==通过加入了程序栈，我们相当于在指令跳转的过程种，加入了一个“记忆”的功能，能在跳转去运行新的指令之后，再回到跳出去的位置，能够实现更加丰富和灵活的指令执行流程。==这个也为我们在程序开发的过程中，提供了“函数”这样一个抽象，使得我们在软件开发的过程中，可以复用代码和指令，而不是只能简单粗暴地复制、粘贴代码和指令。

#### 3.5推荐阅读

如果你觉得还不过瘾，可以仔细读一下《深入理解计算机系统（第三版）》的 3.7 小节《过程》，进一步了解函数调用是怎么回事。

另外，我推荐你花一点时间，通过搜索引擎搞清楚 function_example.c 每一行汇编代码的含义，这个能够帮你进一步深入了解程序栈、栈帧、寄存器以及 Intel CPU 的指令集。

#### 3.6课后思考

在程序栈里面，除了我们跳转前的指令地址外，还需要保留哪些信息，才能在我们在函数调用完成之后，跳转回到指令地址的时候，继续执行完函数调用之后的指令呢？

##### 3.6.1开篇

本篇文章着重写的是系统中栈的工作原理，以及函数调用过程中栈帧的产生与释放的过程。

##### 3.6.2内存的不同用途

根据不同的操作系统，一个进程可能被分配到不同的内存区域去执行。但是不管什么样的操作系统、什么样的计算机架构，进程使用的内存都可以按照功能大致分为以下4个部分：

1. 代码区：这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取指令并执行。
2. 数据区：用于存储全局变量等。
3. 堆区：进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。
4. 栈区：用于动态地存储函数之间的关系，以保证被调用函数在返回时恢复到母函数中继续执行。

在Windows平台下，高级语言写出的程序经过编译链接，最终会变成PE文件。当PE文件被装载运行后，就成了所谓的进程。

==PE文件代码段中包含的二进制级别的机器代码会被装入内存的代码区(.text)，处理器将到内存的这个区域一条一条地取出指令和操作数，并送入运算逻辑单元进行运算；如果代码中请求开辟动态内存，则会在内存的堆区分配一块大小合适的区域返回给代码区的代码使用；当函数调用发生时，函数的调用关系等信息会动态地保存在内存的栈区，以供处理器在执行完被调用函数的代码时，返回母函数。==

##### 3.6.3函数调用约定与相关指令

`函数调用约定描述了函数传递参数方式和栈帧同工作的技术细节。`不同的操作系统、不同的语言、不同的编译器在实现函数调用时的原理虽然基本相同，但具体的调用约定还是有差别的。这包括参数传递方式，参数入栈顺序是从右向左还是从左向右，函数返回时恢复堆栈平衡的操作在子函数中进行还是在母函数中进行。

![image-20230105105046235](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105105046235.png)

　具体的，对于Visual C++来说，可支持以下3种函数调用约定：

![image-20230105105107504](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105105107504.png)

如果要明确使用某一种调用约定，只需要在函数前加上调用约定的声明即可，否则默认情况下，VC会使用`_stdcall`的调用方式。 除了参数入栈方向和恢复栈平衡操作位置的不同之外，参数传递有时也会有所不同。例如，`每一个C++类成员函数都有一个this指针，在Windows平台中，这个指针一般是用ECX寄存器来传递的，但如果用GCC编译器来编译，这个指针会作为最后一个参数压入栈中。`

==注意：同一段代码用不同的编译选项、不同的编译器编译链接后，得到的可执行文件会有很多不同。==

函数调用大概包括以下几个步骤：

(1)`参数入栈`：将参数`从右向左`依次压入系统栈中。

(2)`返回地址入栈`：将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行。

(3)`代码区跳转`：处理器从当前代码区跳转到被调用函数的入口处。

(4)`栈帧调整`：具体包括：

  　　<1>保存当前栈帧状态值，已备后面恢复本栈帧时使用(EBP入栈)。

  　   <2>将当前栈帧切换到新栈帧(将ESP值装入EBP，更新栈帧底部)。

  　　<3>给新栈帧分配空间(把ESP减去所需空间的大小，抬高栈顶)。

  　　<4>对于_stdcall调用约定，函数调用时用到的指令序列大致如下：

```assembly
push 参数3      ;假设该函数有3个参数，将从右向做依次入栈
push 参数2
push 参数1
call 函数地址   ;call指令将同时完成两项工作：a)向栈中压入当前指令地址的下一个指令地址，即保存返回地址。 b)跳转到所调用函数的入口处。
push  ebp      ;保存旧栈帧的底部
mov   ebp,esp  ;设置新栈帧的底部 (栈帧切换)
sub   esp,xxx  ;设置新栈帧的顶部 (抬高栈顶，为新栈帧开辟空间)
```

函数返回的步骤如下：

<1>保存返回值，通常将函数的返回值保存在寄存器`EAX`中。

<2>`弹出当前帧，恢复上一个栈帧`。具体包括：

  　　(1)`在堆栈平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前栈帧的空间。`

  　　(2)`将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复出上一个栈帧。`

  　　(3)`将函数返回地址弹给EIP寄存器。`

<3>`跳转`：按照函数返回地址跳回母函数中继续执行。

还是以C语言和Win32平台为例，函数返回时的相关的指令序列如下：

```assembly
add esp,xxx     ;降低栈顶，回收当前的栈帧
pop ebp         ;将上一个栈帧底部位置恢复到ebp
ret             ;a)弹出当前栈顶元素，即弹出栈帧中的返回地址，至此，栈帧恢复到上一个栈帧工作完成。b)让处理器跳转到弹出的返回地址，恢复调用前代码区
```

##### 3.6.4寄存器与函数栈帧

每一个函数独占自己的栈帧空间。当前正在运行的函数的栈帧总是在栈顶。Win32系统提供两个特殊的寄存器用于标识位于系统栈顶端的栈帧。

(1)`ESP`：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。

(2)`EBP`：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。 

![image-20230105105727123](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105105727123.png)

函数栈帧：ESP和EBP之间的内存空间为当前栈帧,EBP标识了当前栈帧的底部，ESP标识了当前栈帧的顶部。

在函数栈帧中，一般包含以下几类重要信息。

(1)局部变量：为函数局部变量开辟的内存空间。

(2)栈帧状态值：保存前栈帧的顶部和底部(实际上只保存前栈帧的底部，前栈帧的顶部可以通过栈帧平衡计算得到)，用于在本栈被弹出后恢复出上一个栈帧。

(3)函数返回地址：保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置，以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令。

==注：函数栈帧的大小并不固定，一般与其对应函数的局部变量多少有关。函数运行过程中，其栈帧大小也是在不停变化的。除了与栈相关的寄存器外，我们还需要记住另一个至关重要的寄存器。==

`EIP`：指令寄存器(extended instruction pointer)，其内存放着一个指针，该指针永远指向下一条等待执行的指令地址。 可以说如果控制了EIP寄存器的内容，就控制了进程——我们让EIP指向哪里，CPU就会去执行哪里的指令。

### 4.ELF和静态链接：为什么程序无法同时在Linux和Windows下运行？

过去的三节，你和我一起通过一些简单的代码，看到了我们写的程序，是怎么变成一条条计算机指令的；if…else 这样的条件跳转是怎么样执行的；for/while 这样的循环是怎么执行的；函数间的相互调用是怎么发生的。

我记得以前，我自己在了解完这些知识之后，产生了一个非常大的疑问。那就是，既然我们的程序最终都被变成了一条条机器码去执行，那为什么同一个程序，在同一台计算机上，在 Linux 下可以运行，而在 Windows 下却不行呢？反过来，Windows 上的程序在 Linux 上也是一样不能执行的。可是我们的 CPU 并没有换掉，它应该可以识别同样的指令呀？

如果你和我有同样的疑问，那这一节，我们就一起来解开。

#### 4.1编译、链接和装载：拆解程序执行

`我们说过，写好的 C 语言代码，可以通过编译器编译成汇编代码，然后汇编代码再通过汇编器变成 CPU 可以理解的机器码，于是 CPU 就可以执行这些机器码了。`你现在对这个过程应该不陌生了，但是这个描述把过程大大简化了。下面，我们一起具体来看，C 语言程序是如何变成一个可执行程序的。

不知道你注意到没有，过去几节，我们通过 gcc 生成的文件和 objdump 获取到的汇编指令都有些小小的问题。我们先把前面的 add 函数示例，拆分成两个文件` add_lib.c `和 `link_example.c`。

```c
// add_lib.c
int add(int a, int b)
{
    return a+b;
}
```

```c
// link_example.c
#include <stdio.h>
int main()
{
    int a = 10;
    int b = 5;
    int c = add(a, b);
    printf("c = %d\n", c);
}
```

我们通过 gcc 来编译这两个文件，然后通过 objdump 命令看看它们的汇编代码。

```shell
$ gcc -g -c add_lib.c link_example.c
$ objdump -d -M intel -S add_lib.o
$ objdump -d -M intel -S link_example.o
```

```shell

add_lib.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <add>:
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
   4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
   7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi
   a:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
   d:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  10:   01 d0                   add    eax,edx
  12:   5d                      pop    rbp
  13:   c3                      ret    
```

```shell

link_example.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <main>:
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
   4:   48 83 ec 10             sub    rsp,0x10
   8:   c7 45 fc 0a 00 00 00    mov    DWORD PTR [rbp-0x4],0xa
   f:   c7 45 f8 05 00 00 00    mov    DWORD PTR [rbp-0x8],0x5
  16:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]
  19:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
  1c:   89 d6                   mov    esi,edx
  1e:   89 c7                   mov    edi,eax
  20:   b8 00 00 00 00          mov    eax,0x0
  25:   e8 00 00 00 00          call   2a <main+0x2a>
  2a:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
  2d:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]
  30:   89 c6                   mov    esi,eax
  32:   48 8d 3d 00 00 00 00    lea    rdi,[rip+0x0]        # 39 <main+0x39>
  39:   b8 00 00 00 00          mov    eax,0x0
  3e:   e8 00 00 00 00          call   43 <main+0x43>
  43:   b8 00 00 00 00          mov    eax,0x0
  48:   c9                      leave  
  49:   c3                      ret    
```

既然代码已经被我们“编译”成了指令，我们不妨尝试运行一下 `./link_example.o`。

不幸的是，文件没有执行权限，我们遇到一个 Permission denied 错误。即使通过 chmod 命令赋予 link_example.o 文件可执行的权限，运行./link_example.o 仍然只会得到一条` cannot execute binary file: Exec format error `的错误。

我们再仔细看一下 objdump 出来的两个文件的代码，会发现`两个程序的地址都是从 0 开始的`。如果地址是一样的，程序如果需要通过 call 指令调用函数的话，它怎么知道应该跳转到哪一个文件里呢？

==这么说吧，无论是这里的运行报错，还是 objdump 出来的汇编代码里面的重复地址，都是因为 add_lib.o 以及 link_example.o 并不是一个可执行文件（Executable Program），而是目标文件（Object File）。只有通过链接器（Linker）把多个目标文件以及调用的各种函数库链接起来，我们才能得到一个可执行文件。==

我们通过 gcc 的 -o 参数，可以生成对应的可执行文件，对应执行之后，就可以得到这个简单的加法调用函数的结果。

```shell
$ gcc -o link-example add_lib.o link_example.o
$ ./link_example
c = 15
```

实际上，“C 语言代码 - 汇编代码 - 机器码” 这个过程，在我们的计算机上进行的时候是由两部分组成的。

==第一个部分由编译（Compile）、汇编（Assemble）以及链接（Link）三个阶段组成。在这三个阶段完成之后，我们就生成了一个可执行文件。==

==第二部分，我们通过装载器（Loader）把可执行文件装载（Load）到内存中。CPU 从内存中读取指令和数据，来开始真正执行程序。==

![image-20230105112555858](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105112555858.png)

#### 4.2ELF 格式和链接：理解链接过程

程序最终是通过装载器变成指令和数据的，所以其实我们生成的可执行代码也并不仅仅是一条条的指令。我们还是通过 objdump 指令，把可执行文件的内容拿出来看看。

```shell

link_example:     file format elf64-x86-64
Disassembly of section .init:
...
Disassembly of section .plt:
...
Disassembly of section .plt.got:
...
Disassembly of section .text:
...

 6b0:   55                      push   rbp
 6b1:   48 89 e5                mov    rbp,rsp
 6b4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
 6b7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi
 6ba:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
 6bd:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
 6c0:   01 d0                   add    eax,edx
 6c2:   5d                      pop    rbp
 6c3:   c3                      ret    
00000000000006c4 <main>:
 6c4:   55                      push   rbp
 6c5:   48 89 e5                mov    rbp,rsp
 6c8:   48 83 ec 10             sub    rsp,0x10
 6cc:   c7 45 fc 0a 00 00 00    mov    DWORD PTR [rbp-0x4],0xa
 6d3:   c7 45 f8 05 00 00 00    mov    DWORD PTR [rbp-0x8],0x5
 6da:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]
 6dd:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
 6e0:   89 d6                   mov    esi,edx
 6e2:   89 c7                   mov    edi,eax
 6e4:   b8 00 00 00 00          mov    eax,0x0
 6e9:   e8 c2 ff ff ff          call   6b0 <add>
 6ee:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
 6f1:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]
 6f4:   89 c6                   mov    esi,eax
 6f6:   48 8d 3d 97 00 00 00    lea    rdi,[rip+0x97]        # 794 <_IO_stdin_used+0x4>
 6fd:   b8 00 00 00 00          mov    eax,0x0
 702:   e8 59 fe ff ff          call   560 <printf@plt>
 707:   b8 00 00 00 00          mov    eax,0x0
 70c:   c9                      leave  
 70d:   c3                      ret    
 70e:   66 90                   xchg   ax,ax
...
Disassembly of section .fini:
...
```

你会发现，可执行代码 dump 出来内容，和之前的目标代码长得差不多，但是长了很多。因为在 Linux 下，可执行文件和目标文件所使用的都是一种叫 `ELF（Execuatable and Linkable File Format）`的文件格式，中文名字叫`可执行与可链接文件格式`，这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。

比如我们过去所有 objdump 出来的代码里，你都可以看到对应的函数名称，像 add、main 等等，乃至你自己定义的全局可以访问的变量名称，都存放在这个 ELF 格式文件里。`这些名字和它们对应的地址，在 ELF 文件里面，存储在一个叫作符号表（Symbols Table）的位置里。`符号表相当于一个地址簿，把名字和地址关联了起来。

我们先只关注和我们的 add 以及 main 函数相关的部分。你会发现，这里面，main 函数里调用 add 的跳转地址，不再是下一条指令的地址了，而是 add 函数的入口地址了，这就是 EFL 格式和链接器的功劳。

![image-20230105112854349](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105112854349.png)

ELF 文件格式把各种信息，分成一个一个的 Section 保存起来。ELF 有一个基本的文件头（File Header），用来表示这个文件的基本属性，比如是否是可执行文件，对应的 CPU、操作系统等等。除了这些基本属性之外，大部分程序还有这么一些 Section：

1. 首先是.text Section，也叫作代码段或者指令段（Code Section），用来保存程序的代码和指令；
2. 接着是.data Section，也叫作数据段（Data Section），用来保存程序里面设置好的初始化数据信息；
3. 然后就是.rel.text Secion，叫作重定位表（Relocation Table）。重定位表里，保留的是当前的文件里面，哪些跳转地址其实是我们不知道的。比如上面的 link_example.o 里面，我们在 main 函数里面调用了 add 和 printf 这两个函数，但是在链接发生之前，我们并不知道该跳转到哪里，这些信息就会存储在重定位表里；
4. 最后是.symtab Section，叫作符号表（Symbol Table）。符号表保留了我们所说的当前文件里面定义的函数名称和对应地址的地址簿。

==链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。这也是为什么，可执行文件里面的函数调用的地址都是正确的。==

![image-20230105113119656](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105113119656.png)

在链接器把程序变成可执行文件之后，要装载器去执行程序就容易多了。装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供 CPU 执行就可以了。

#### 4.3总结延伸

讲到这里，相信你已经猜到，为什么同样一个程序，在 Linux 下可以执行而在 Windows 下不能执行了。==其中一个非常重要的原因就是，两个操作系统下可执行文件的格式不一样。==

我们今天讲的是 Linux 下的 ELF 文件格式，而 Windows 的可执行文件格式是一种叫作 PE（Portable Executable Format）的文件格式。`Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式。`

如果我们有一个可以能够解析 PE 格式的装载器，我们就有可能在 Linux 下运行 Windows 程序了。这样的程序真的存在吗？没错，Linux 下著名的开源项目 Wine，就是通过兼容 PE 格式的装载器，使得我们能直接在 Linux 下运行 Windows 程序的。而现在微软的 Windows 里面也提供了 WSL，也就是 Windows Subsystem for Linux，可以解析和加载 ELF 格式的文件。

> 在linux上使用过wine，有好多window软件不能很好兼容的运行，这是为什么呢？
>
> 因为很多程序还依赖各种操作系统本身提供的动态链接库，系统调用等等。需要wine提供对应的实现，兼容格式只是万里长征第一步。

我们去写可以用的程序，也不仅仅是把所有代码放在一个文件里来编译执行，而是可以拆分成不同的函数库，最后通过一个静态链接的机制，使得不同的文件之间既有分工，又能通过静态链接来“合作”，变成一个可执行的程序。

对于 ELF 格式的文件，为了能够实现这样一个静态链接的机制，里面不只是简单罗列了程序所需要执行的指令，还会包括链接所需要的重定位表和符号表。

#### 4.4推荐阅读

想要更深入了解程序的链接过程和 ELF 格式，我推荐你阅读《程序员的自我修养——链接、装载和库》的 1～4 章。这是一本难得的讲解程序的链接、装载和运行的好书。

#### 4.5课后思考

你可以通过` readelf `读取出今天演示程序的符号表，看看符号表里都有哪些信息；然后通过` objdump `读取出今天演示程序的重定位表，看看里面又有哪些信息。

```shell
[root@Linux学习 深入理解计算机组成原理]# objdump -d -M intel -S link-example 
link-example：     文件格式 elf64-x86-64
Disassembly of section .init:

00000000004003c8 <_init>:
  4003c8:	48 83 ec 08          	sub    rsp,0x8
  4003cc:	48 8b 05 25 0c 20 00 	mov    rax,QWORD PTR [rip+0x200c25]        # 600ff8 <__gmon_start__>
  4003d3:	48 85 c0             	test   rax,rax
  4003d6:	74 05                	je     4003dd <_init+0x15>
  4003d8:	e8 43 00 00 00       	call   400420 <.plt.got>
  4003dd:	48 83 c4 08          	add    rsp,0x8
  4003e1:	c3                   	ret    

Disassembly of section .plt:

00000000004003f0 <.plt>:
  4003f0:	ff 35 12 0c 20 00    	push   QWORD PTR [rip+0x200c12]        # 601008 <_GLOBAL_OFFSET_TABLE_+0x8>
  4003f6:	ff 25 14 0c 20 00    	jmp    QWORD PTR [rip+0x200c14]        # 601010 <_GLOBAL_OFFSET_TABLE_+0x10>
  4003fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000400400 <printf@plt>:
  400400:	ff 25 12 0c 20 00    	jmp    QWORD PTR [rip+0x200c12]        # 601018 <printf@GLIBC_2.2.5>
  400406:	68 00 00 00 00       	push   0x0
  40040b:	e9 e0 ff ff ff       	jmp    4003f0 <.plt>

0000000000400410 <__libc_start_main@plt>:
  400410:	ff 25 0a 0c 20 00    	jmp    QWORD PTR [rip+0x200c0a]        # 601020 <__libc_start_main@GLIBC_2.2.5>
  400416:	68 01 00 00 00       	push   0x1
  40041b:	e9 d0 ff ff ff       	jmp    4003f0 <.plt>

Disassembly of section .plt.got:

0000000000400420 <.plt.got>:
  400420:	ff 25 d2 0b 20 00    	jmp    QWORD PTR [rip+0x200bd2]        # 600ff8 <__gmon_start__>
  400426:	66 90                	xchg   ax,ax

Disassembly of section .text:

0000000000400430 <_start>:
  400430:	31 ed                	xor    ebp,ebp
  400432:	49 89 d1             	mov    r9,rdx
  400435:	5e                   	pop    rsi
  400436:	48 89 e2             	mov    rdx,rsp
  400439:	48 83 e4 f0          	and    rsp,0xfffffffffffffff0
  40043d:	50                   	push   rax
  40043e:	54                   	push   rsp
  40043f:	49 c7 c0 f0 05 40 00 	mov    r8,0x4005f0
  400446:	48 c7 c1 80 05 40 00 	mov    rcx,0x400580
  40044d:	48 c7 c7 31 05 40 00 	mov    rdi,0x400531
  400454:	e8 b7 ff ff ff       	call   400410 <__libc_start_main@plt>
  400459:	f4                   	hlt    
  40045a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000400460 <deregister_tm_clones>:
  400460:	b8 37 10 60 00       	mov    eax,0x601037
  400465:	55                   	push   rbp
  400466:	48 2d 30 10 60 00    	sub    rax,0x601030
  40046c:	48 83 f8 0e          	cmp    rax,0xe
  400470:	48 89 e5             	mov    rbp,rsp
  400473:	77 02                	ja     400477 <deregister_tm_clones+0x17>
  400475:	5d                   	pop    rbp
  400476:	c3                   	ret    
  400477:	b8 00 00 00 00       	mov    eax,0x0
  40047c:	48 85 c0             	test   rax,rax
  40047f:	74 f4                	je     400475 <deregister_tm_clones+0x15>
  400481:	5d                   	pop    rbp
  400482:	bf 30 10 60 00       	mov    edi,0x601030
  400487:	ff e0                	jmp    rax
  400489:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000400490 <register_tm_clones>:
  400490:	b8 30 10 60 00       	mov    eax,0x601030
  400495:	55                   	push   rbp
  400496:	48 2d 30 10 60 00    	sub    rax,0x601030
  40049c:	48 c1 f8 03          	sar    rax,0x3
  4004a0:	48 89 e5             	mov    rbp,rsp
  4004a3:	48 89 c2             	mov    rdx,rax
  4004a6:	48 c1 ea 3f          	shr    rdx,0x3f
  4004aa:	48 01 d0             	add    rax,rdx
  4004ad:	48 d1 f8             	sar    rax,1
  4004b0:	75 02                	jne    4004b4 <register_tm_clones+0x24>
  4004b2:	5d                   	pop    rbp
  4004b3:	c3                   	ret    
  4004b4:	ba 00 00 00 00       	mov    edx,0x0
  4004b9:	48 85 d2             	test   rdx,rdx
  4004bc:	74 f4                	je     4004b2 <register_tm_clones+0x22>
  4004be:	5d                   	pop    rbp
  4004bf:	48 89 c6             	mov    rsi,rax
  4004c2:	bf 30 10 60 00       	mov    edi,0x601030
  4004c7:	ff e2                	jmp    rdx
  4004c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

00000000004004d0 <__do_global_dtors_aux>:
  4004d0:	80 3d 55 0b 20 00 00 	cmp    BYTE PTR [rip+0x200b55],0x0        # 60102c <_edata>
  4004d7:	75 11                	jne    4004ea <__do_global_dtors_aux+0x1a>
  4004d9:	55                   	push   rbp
  4004da:	48 89 e5             	mov    rbp,rsp
  4004dd:	e8 7e ff ff ff       	call   400460 <deregister_tm_clones>
  4004e2:	5d                   	pop    rbp
  4004e3:	c6 05 42 0b 20 00 01 	mov    BYTE PTR [rip+0x200b42],0x1        # 60102c <_edata>
  4004ea:	f3 c3                	repz ret 
  4004ec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000004004f0 <frame_dummy>:
  4004f0:	48 83 3d 28 09 20 00 	cmp    QWORD PTR [rip+0x200928],0x0        # 600e20 <__JCR_END__>
  4004f7:	00 
  4004f8:	74 1e                	je     400518 <frame_dummy+0x28>
  4004fa:	b8 00 00 00 00       	mov    eax,0x0
  4004ff:	48 85 c0             	test   rax,rax
  400502:	74 14                	je     400518 <frame_dummy+0x28>
  400504:	55                   	push   rbp
  400505:	bf 20 0e 60 00       	mov    edi,0x600e20
  40050a:	48 89 e5             	mov    rbp,rsp
  40050d:	ff d0                	call   rax
  40050f:	5d                   	pop    rbp
  400510:	e9 7b ff ff ff       	jmp    400490 <register_tm_clones>
  400515:	0f 1f 00             	nop    DWORD PTR [rax]
  400518:	e9 73 ff ff ff       	jmp    400490 <register_tm_clones>

000000000040051d <add>:
// add_lib.c
int add(int a, int b)
{
  40051d:	55                   	push   rbp
  40051e:	48 89 e5             	mov    rbp,rsp
  400521:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
  400524:	89 75 f8             	mov    DWORD PTR [rbp-0x8],esi
     return a+b;
  400527:	8b 45 f8             	mov    eax,DWORD PTR [rbp-0x8]
  40052a:	8b 55 fc             	mov    edx,DWORD PTR [rbp-0x4]
  40052d:	01 d0                	add    eax,edx
}
  40052f:	5d                   	pop    rbp
  400530:	c3                   	ret    

0000000000400531 <main>:
// link_example.c
#include <stdio.h>
int main()
{
  400531:	55                   	push   rbp
  400532:	48 89 e5             	mov    rbp,rsp
  400535:	48 83 ec 10          	sub    rsp,0x10
    int a = 10;
  400539:	c7 45 fc 0a 00 00 00 	mov    DWORD PTR [rbp-0x4],0xa
    int b = 5;
  400540:	c7 45 f8 05 00 00 00 	mov    DWORD PTR [rbp-0x8],0x5
    int c = add(a, b);
  400547:	8b 55 f8             	mov    edx,DWORD PTR [rbp-0x8]
  40054a:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  40054d:	89 d6                	mov    esi,edx
  40054f:	89 c7                	mov    edi,eax
  400551:	b8 00 00 00 00       	mov    eax,0x0
  400556:	e8 c2 ff ff ff       	call   40051d <add>
  40055b:	89 45 f4             	mov    DWORD PTR [rbp-0xc],eax
    printf("c = %d\n", c);
  40055e:	8b 45 f4             	mov    eax,DWORD PTR [rbp-0xc]
  400561:	89 c6                	mov    esi,eax
  400563:	bf 10 06 40 00       	mov    edi,0x400610
  400568:	b8 00 00 00 00       	mov    eax,0x0
  40056d:	e8 8e fe ff ff       	call   400400 <printf@plt>
}
  400572:	c9                   	leave  
  400573:	c3                   	ret    
  400574:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  40057b:	00 00 00 
  40057e:	66 90                	xchg   ax,ax

0000000000400580 <__libc_csu_init>:
  400580:	41 57                	push   r15
  400582:	41 89 ff             	mov    r15d,edi
  400585:	41 56                	push   r14
  400587:	49 89 f6             	mov    r14,rsi
  40058a:	41 55                	push   r13
  40058c:	49 89 d5             	mov    r13,rdx
  40058f:	41 54                	push   r12
  400591:	4c 8d 25 78 08 20 00 	lea    r12,[rip+0x200878]        # 600e10 <__frame_dummy_init_array_entry>
  400598:	55                   	push   rbp
  400599:	48 8d 2d 78 08 20 00 	lea    rbp,[rip+0x200878]        # 600e18 <__init_array_end>
  4005a0:	53                   	push   rbx
  4005a1:	4c 29 e5             	sub    rbp,r12
  4005a4:	31 db                	xor    ebx,ebx
  4005a6:	48 c1 fd 03          	sar    rbp,0x3
  4005aa:	48 83 ec 08          	sub    rsp,0x8
  4005ae:	e8 15 fe ff ff       	call   4003c8 <_init>
  4005b3:	48 85 ed             	test   rbp,rbp
  4005b6:	74 1e                	je     4005d6 <__libc_csu_init+0x56>
  4005b8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4005bf:	00 
  4005c0:	4c 89 ea             	mov    rdx,r13
  4005c3:	4c 89 f6             	mov    rsi,r14
  4005c6:	44 89 ff             	mov    edi,r15d
  4005c9:	41 ff 14 dc          	call   QWORD PTR [r12+rbx*8]
  4005cd:	48 83 c3 01          	add    rbx,0x1
  4005d1:	48 39 eb             	cmp    rbx,rbp
  4005d4:	75 ea                	jne    4005c0 <__libc_csu_init+0x40>
  4005d6:	48 83 c4 08          	add    rsp,0x8
  4005da:	5b                   	pop    rbx
  4005db:	5d                   	pop    rbp
  4005dc:	41 5c                	pop    r12
  4005de:	41 5d                	pop    r13
  4005e0:	41 5e                	pop    r14
  4005e2:	41 5f                	pop    r15
  4005e4:	c3                   	ret    
  4005e5:	90                   	nop
  4005e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  4005ed:	00 00 00 

00000000004005f0 <__libc_csu_fini>:
  4005f0:	f3 c3                	repz ret 

Disassembly of section .fini:

00000000004005f4 <_fini>:
  4005f4:	48 83 ec 08          	sub    rsp,0x8
  4005f8:	48 83 c4 08          	add    rsp,0x8
  4005fc:	c3                   	ret
```

```shell
[root@Linux学习 深入理解计算机组成原理]# readelf -s link-example 

Symbol table '.dynsym' contains 4 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.2.5 (2)
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.2.5 (2)
     3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__

Symbol table '.symtab' contains 71 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000400238     0 SECTION LOCAL  DEFAULT    1 
     2: 0000000000400254     0 SECTION LOCAL  DEFAULT    2 
     3: 0000000000400274     0 SECTION LOCAL  DEFAULT    3 
     4: 0000000000400298     0 SECTION LOCAL  DEFAULT    4 
     5: 00000000004002b8     0 SECTION LOCAL  DEFAULT    5 
     6: 0000000000400318     0 SECTION LOCAL  DEFAULT    6 
     7: 0000000000400358     0 SECTION LOCAL  DEFAULT    7 
     8: 0000000000400360     0 SECTION LOCAL  DEFAULT    8 
     9: 0000000000400380     0 SECTION LOCAL  DEFAULT    9 
    10: 0000000000400398     0 SECTION LOCAL  DEFAULT   10 
    11: 00000000004003c8     0 SECTION LOCAL  DEFAULT   11 
    12: 00000000004003f0     0 SECTION LOCAL  DEFAULT   12 
    13: 0000000000400420     0 SECTION LOCAL  DEFAULT   13 
    14: 0000000000400430     0 SECTION LOCAL  DEFAULT   14 
    15: 00000000004005f4     0 SECTION LOCAL  DEFAULT   15 
    16: 0000000000400600     0 SECTION LOCAL  DEFAULT   16 
    17: 0000000000400618     0 SECTION LOCAL  DEFAULT   17 
    18: 0000000000400658     0 SECTION LOCAL  DEFAULT   18 
    19: 0000000000600e10     0 SECTION LOCAL  DEFAULT   19 
    20: 0000000000600e18     0 SECTION LOCAL  DEFAULT   20 
    21: 0000000000600e20     0 SECTION LOCAL  DEFAULT   21 
    22: 0000000000600e28     0 SECTION LOCAL  DEFAULT   22 
    23: 0000000000600ff8     0 SECTION LOCAL  DEFAULT   23 
    24: 0000000000601000     0 SECTION LOCAL  DEFAULT   24 
    25: 0000000000601028     0 SECTION LOCAL  DEFAULT   25 
    26: 000000000060102c     0 SECTION LOCAL  DEFAULT   26 
    27: 0000000000000000     0 SECTION LOCAL  DEFAULT   27 
    28: 0000000000000000     0 SECTION LOCAL  DEFAULT   28 
    29: 0000000000000000     0 SECTION LOCAL  DEFAULT   29 
    30: 0000000000000000     0 SECTION LOCAL  DEFAULT   30 
    31: 0000000000000000     0 SECTION LOCAL  DEFAULT   31 
    32: 0000000000000000     0 SECTION LOCAL  DEFAULT   32 
    33: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
    34: 0000000000600e20     0 OBJECT  LOCAL  DEFAULT   21 __JCR_LIST__
    35: 0000000000400460     0 FUNC    LOCAL  DEFAULT   14 deregister_tm_clones
    36: 0000000000400490     0 FUNC    LOCAL  DEFAULT   14 register_tm_clones
    37: 00000000004004d0     0 FUNC    LOCAL  DEFAULT   14 __do_global_dtors_aux
    38: 000000000060102c     1 OBJECT  LOCAL  DEFAULT   26 completed.6355
    39: 0000000000600e18     0 OBJECT  LOCAL  DEFAULT   20 __do_global_dtors_aux_fin
    40: 00000000004004f0     0 FUNC    LOCAL  DEFAULT   14 frame_dummy
    41: 0000000000600e10     0 OBJECT  LOCAL  DEFAULT   19 __frame_dummy_init_array_
    42: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS add_lib.c
    43: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS link_example.c
    44: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
    45: 0000000000400768     0 OBJECT  LOCAL  DEFAULT   18 __FRAME_END__
    46: 0000000000600e20     0 OBJECT  LOCAL  DEFAULT   21 __JCR_END__
    47: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS 
    48: 0000000000600e18     0 NOTYPE  LOCAL  DEFAULT   19 __init_array_end
    49: 0000000000600e28     0 OBJECT  LOCAL  DEFAULT   22 _DYNAMIC
    50: 0000000000600e10     0 NOTYPE  LOCAL  DEFAULT   19 __init_array_start
    51: 0000000000400618     0 NOTYPE  LOCAL  DEFAULT   17 __GNU_EH_FRAME_HDR
    52: 0000000000601000     0 OBJECT  LOCAL  DEFAULT   24 _GLOBAL_OFFSET_TABLE_
    53: 00000000004005f0     2 FUNC    GLOBAL DEFAULT   14 __libc_csu_fini
    54: 0000000000601028     0 NOTYPE  WEAK   DEFAULT   25 data_start
    55: 000000000040051d    20 FUNC    GLOBAL DEFAULT   14 add
    56: 000000000060102c     0 NOTYPE  GLOBAL DEFAULT   25 _edata
    57: 00000000004005f4     0 FUNC    GLOBAL DEFAULT   15 _fini
    58: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@@GLIBC_2.2.5
    59: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_
    60: 0000000000601028     0 NOTYPE  GLOBAL DEFAULT   25 __data_start
    61: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    62: 0000000000400608     0 OBJECT  GLOBAL HIDDEN    16 __dso_handle
    63: 0000000000400600     4 OBJECT  GLOBAL DEFAULT   16 _IO_stdin_used
    64: 0000000000400580   101 FUNC    GLOBAL DEFAULT   14 __libc_csu_init
    65: 0000000000601030     0 NOTYPE  GLOBAL DEFAULT   26 _end
    66: 0000000000400430     0 FUNC    GLOBAL DEFAULT   14 _start
    67: 000000000060102c     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start
    68: 0000000000400531    67 FUNC    GLOBAL DEFAULT   14 main
    69: 0000000000601030     0 OBJECT  GLOBAL HIDDEN    25 __TMC_END__
    70: 00000000004003c8     0 FUNC    GLOBAL DEFAULT   11 _init
```

```shell
[root@Linux学习 深入理解计算机组成原理]# objdump -r link-example 

link-example：     文件格式 elf64-x86-64

[root@Linux学习 深入理解计算机组成原理]# objdump -r link_example.o

link_example.o：     文件格式 elf64-x86-64

RELOCATION RECORDS FOR [.text]:
OFFSET           TYPE              VALUE 
0000000000000026 R_X86_64_PC32     add-0x0000000000000004
0000000000000033 R_X86_64_32       .rodata
000000000000003d R_X86_64_PC32     printf-0x0000000000000004


RELOCATION RECORDS FOR [.debug_info]:
OFFSET           TYPE              VALUE 
0000000000000006 R_X86_64_32       .debug_abbrev
000000000000000c R_X86_64_32       .debug_str+0x0000000000000020
0000000000000011 R_X86_64_32       .debug_str+0x00000000000000ea
0000000000000015 R_X86_64_32       .debug_str+0x000000000000007f
0000000000000019 R_X86_64_64       .text
0000000000000029 R_X86_64_32       .debug_line
0000000000000030 R_X86_64_32       .debug_str+0x0000000000000068
0000000000000037 R_X86_64_32       .debug_str+0x00000000000000af
000000000000003e R_X86_64_32       .debug_str
0000000000000045 R_X86_64_32       .debug_str+0x0000000000000013
000000000000004c R_X86_64_32       .debug_str+0x00000000000000cb
0000000000000053 R_X86_64_32       .debug_str+0x00000000000000d7
0000000000000061 R_X86_64_32       .debug_str+0x00000000000000c2
0000000000000068 R_X86_64_32       .debug_str+0x00000000000000e1
000000000000006f R_X86_64_32       .debug_str+0x000000000000007a
0000000000000074 R_X86_64_32       .debug_str+0x00000000000000bd
000000000000007e R_X86_64_64       .text


RELOCATION RECORDS FOR [.debug_aranges]:
OFFSET           TYPE              VALUE 
0000000000000006 R_X86_64_32       .debug_info
0000000000000010 R_X86_64_64       .text


RELOCATION RECORDS FOR [.debug_line]:
OFFSET           TYPE              VALUE 
0000000000000032 R_X86_64_64       .text


RELOCATION RECORDS FOR [.eh_frame]:
OFFSET           TYPE              VALUE 
0000000000000020 R_X86_64_PC32     .text
```

### 5.程序装载：“640K内存”真的不够用么？

计算机这个行业的历史上有过很多成功的预言，最著名的自然是“摩尔定律”。当然免不了的也有很多“失败”的预测，其中一个最著名的就是，比尔·盖茨在上世纪 80 年代说的`“640K ought to be enough for anyone”`，也就是“640K 内存对哪个人来说都够用了”。

那个年代，微软开发的还是 DOS 操作系统，程序员们还在绞尽脑汁，想要用好这极为有限的 640K 内存。而现在，我手头的开发机已经是 16G 内存了，上升了一万倍还不止。那比尔·盖茨这句话在当时也是完全的无稽之谈么？有没有哪怕一点点的道理呢？这一讲里，我就和你一起来看一看。

#### 5.1程序装载面临的挑战

上一讲，我们看到了如何通过链接器，把多个文件合并成一个最终可执行文件。`在运行这些可执行文件的时候，我们其实是通过一个装载器，解析 ELF 或者 PE 格式的可执行文件。装载器会把对应的指令和数据加载到内存里面来，让 CPU 去执行。`

说起来只是装载到内存里面这一句话的事儿，实际上装载器需要满足两个要求。

==第一，可执行程序加载后占用的内存空间应该是连续的。==我们讲过，执行指令的时候，程序计数器是顺序地一条一条指令执行下去。这也就意味着，这一条条指令需要连续地存储在一起。

==第二，我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置。==虽然编译出来的指令里已经有了对应的各种各样的内存地址，但是实际加载的时候，我们其实没有办法确保，这个程序一定加载在哪一段内存地址上。因为我们现在的计算机通常会同时运行很多个程序，可能你想要的内存地址已经被其他加载了的程序占用了。

要满足这两个基本的要求，我们很容易想到一个办法。`那就是我们可以在内存里面，找到一段连续的内存空间，然后分配给装载的程序，然后把这段连续的内存空间地址，和整个程序指令里指定的内存地址做一个映射。`

我们把指令里用到的内存地址叫作`虚拟内存地址（Virtual Memory Address）`，实际在内存硬件里面的空间地址，我们叫`物理内存地址（Physical Memory Address）`。

程序里有指令和各种内存地址，我们只需要关心虚拟内存地址就行了。对于任何一个程序来说，它看到的都是同样的内存地址。我们维护一个虚拟内存到物理内存的映射表，这样实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。`因为是连续的内存地址空间，所以我们只需要维护映射关系的起始地址和对应的空间大小就可以了。`

#### 5.2内存分段

这种找出一段连续的物理内存和虚拟内存地址进行映射的方法，我们叫`分段（Segmentation）`。这里的段，就是指系统分配出来的那个连续的内存空间。

![image-20230105132821942](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105132821942.png)

分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处，第一个就是`内存碎片（Memory Fragmentation）`的问题。

我们来看这样一个例子。我现在手头的这台电脑，有 1GB 的内存。我们先启动一个图形渲染程序，占用了 512MB 的内存，接着启动一个 Chrome 浏览器，占用了 128MB 内存，再启动一个 Python 程序，占用了 256MB 内存。这个时候，我们关掉 Chrome，于是空闲内存还有 1024 - 512 - 256 = 256MB。按理来说，我们有足够的空间再去装载一个 200MB 的程序。但是，这 256MB 的内存空间不是连续的，而是被分成了两段 128MB 的内存。因此，实际情况是，我们的程序没办法加载进来。

![image-20230105132950407](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105132950407.png)

当然，这个我们也有办法解决。解决的办法叫`内存交换（Memory Swapping）`。

我们可以把 Python 程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里面。不过读回来的时候，我们不再把它加载到原来的位置，而是紧紧跟在那已经被占用了的 512MB 内存后面。这样，我们就有了连续的 256MB 内存空间，就可以去加载一个新的 200MB 的程序。如果你自己安装过 Linux 操作系统，你应该遇到过分配一个 swap 硬盘分区的问题。这块分出来的磁盘空间，其实就是专门给 Linux 操作系统进行内存交换用的。

虚拟内存、分段，再加上内存交换，看起来似乎已经解决了计算机同时装载运行很多个程序的问题。不过，你千万不要大意，这三者的组合仍然会遇到一个性能瓶颈。`硬盘的访问速度要比内存慢很多，而每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，如果内存交换的时候，交换的是一个很占内存空间的程序，这样整个机器都会显得卡顿。`

#### 5.3内存分页

既然问题出在内存碎片和内存交换的空间太大上，那么解决问题的办法就是，少出现一些内存碎片。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决这个问题。这个办法，在现在计算机的内存管理里面，就叫作`内存分页（Paging）`。

==和分段这样分配一整段连续的空间给到程序相比，分页是把整个物理内存空间切成一段段固定尺寸的大小。==而对应的程序所需要占用的虚拟内存空间，也会同样切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。`从虚拟内存到物理内存的映射，不再是拿整段连续的内存的物理地址，而是按照一个一个页来的。`页的尺寸一般远远小于整个程序的大小。在 Linux 下，我们通常只设置成` 4KB`。你可以通过命令看看你手头的 Linux 系统设置的页的大小。

```shell
$ getconf PAGE_SIZE
```

由于内存空间都是预先划分好的，也就没有了不能使用的碎片，而只有被释放出来的很多 4KB 的页。即使内存空间不够，需要让现有的、正在运行的其他程序，通过内存交换释放出一些内存的页出来，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，让整个机器被内存交换的过程给卡住。

![image-20230105133556868](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105133556868.png)

更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。==我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。==

实际上，我们的操作系统，的确是这么做的。当要读取特定的页，却发现数据并没有加载到物理内存里的时候，就会触发一个来自于 CPU 的`缺页错误（Page Fault）`。我们的操作系统会捕捉到这个错误，然后将对应的页，从存放在硬盘上的虚拟内存里读取出来，加载到物理内存里。这种方式，使得我们可以运行那些远大于我们实际物理内存的程序。同时，这样一来，任何程序都不需要一次性加载完所有指令和数据，只需要加载当前需要用到就行了。

通过虚拟内存、内存交换和内存分页这三个技术的组合，我们最终得到了一个让程序不需要考虑实际的物理内存地址、大小和当前分配空间的解决方案。这些技术和方法，对于我们程序的编写、编译和链接过程都是透明的。这也是我们在计算机的软硬件开发中常用的一种方法，就是加入一个间接层。

`通过引入虚拟内存、页映射和内存交换，我们的程序本身，就不再需要考虑对应的真实的内存地址、程序加载、内存管理等问题了。任何一个程序，都只需要把内存当成是一块完整而连续的空间来直接使用。`

#### 5.4总结延伸

现在回到开头我问你的问题，我们的电脑只要 640K 内存就够了吗？很显然，现在来看，比尔·盖茨的这个判断是不合理的，那为什么他会这么认为呢？因为他也是一个很优秀的程序员啊！

`在虚拟内存、内存交换和内存分页这三者结合之下，你会发现，其实要运行一个程序，“必需”的内存是很少的。`CPU 只需要执行当前的指令，极限情况下，内存也只需要加载一页就好了。再大的程序，也可以分成一页。每次，只在需要用到对应的数据和指令的时候，从硬盘上交换到内存里面来就好了。以我们现在 4K 内存一页的大小，640K 内存也能放下足足 160 页呢，也无怪乎在比尔·盖茨会说出“640K ought to be enough for anyone”这样的话。

不过呢，硬盘的访问速度比内存慢很多，所以我们现在的计算机，没有个几 G 的内存都不好意思和人打招呼。

那么，除了程序分页装载这种方式之外，我们还有其他优化内存使用的方式么？下一讲，我们就一起来看看`“动态装载”`，学习一下让两个不同的应用程序，共用一个共享程序库的办法。

#### 5.5推荐阅读

想要更深入地了解代码装载的详细过程，推荐你阅读《程序员的自我修养——链接、装载和库》的第 1 章和第 6 章。

#### 5.6课后思考

请你想一想，在 Java 这样使用虚拟机的编程语言里面，我们写的程序是怎么装载到内存里面来的呢？它也和我们讲的一样，是通过内存分页和内存交换的方式加载到内存里面来的么？

1. 在 Java 这样使用虚拟机的编程语言里面，我们写的程序是怎么装载到内存里面来的呢？ 答：首先，我们编写的Java程序，即源代码`.java`文件经过编译生成字节码文件`.class`； 然后，创建JVM环境，即查找和装载`libjvm.so`文件； 最后，通过创建JVM实例，加载主类的字节码文件到系统给该JVM实例分配的内存中； 

2. 它也和我们讲的一样，是通过内存分页和内存交换的方式加载到内存里面来的么？ 

   答：Java代码的执行需要JVM环境，JVM环境的创建就是查找和装载`libjvm.so`文件：装载`libjvm.so`是通过内存分页和内存交换的方式加载到内存的。 字节码文件是通过类加载器加载到主类文件对应的JVM实例的内存空间中的，这一部分不是使用内存分页和内存交换的方式来管理的，使用的是JVM的内存分配策略来管理的；

### 6.动态链接：程序内部的“共享单车”

我们之前讲过，程序的链接，是把对应的不同文件内的代码段，合并到一起，成为最后的可执行文件。`这个链接的方式，让我们在写代码的时候做到了“复用”。同样的功能代码只要写一次，然后提供给很多不同的程序进行链接就行了。`

这么说来，“链接”其实有点儿像我们日常生活中的标准化、模块化生产。我们有一个可以生产标准螺帽的生产线，就可以生产很多个不同的螺帽。只要需要螺帽，我们都可以通过`链接`的方式，去`复制`一个出来，放到需要的地方去，大到汽车，小到信箱。

`但是，如果我们有很多个程序都要通过装载器装载到内存里面，那里面链接好的同样的功能代码，也都需要再装载一遍，再占一遍内存空间`。这就好比，假设每个人都有骑自行车的需要，那我们给每个人都生产一辆自行车带在身边，固然大家都有自行车用了，但是马路上肯定会特别拥挤。

![image-20230105140822654](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105140822654.png)

#### 6.1链接可以分动、静，共享运行省内存

我们上一节解决程序装载到内存的时候，讲了很多方法。说起来，最根本的问题其实就是内存空间不够用。如果我们能够让同样功能的代码，在不同的程序里面，不需要各占一份内存空间，那该有多好啊！就好比，现在马路上的共享单车，我们并不需要给每个人都造一辆自行车，只要马路上有这些单车，谁需要的时候，直接通过手机扫码，都可以解锁骑行。

这个思路就引入一种新的链接方法，叫作`动态链接（Dynamic Link）`。相应的，我们之前说的合并代码段的方法，就是`静态链接（Static Link）`。

==在动态链接的过程中，我们想要“链接”的，不是存储在硬盘上的目标文件代码，而是加载到内存中的共享库（Shared Libraries）==。顾名思义，这里的共享库重在“共享“这两个字。

这个加载到内存中的共享库会被很多个程序的指令调用到。在 Windows 下，这些共享库文件就是`.dll` 文件，也就是 `Dynamic-Link Libary（DLL，动态链接库）`。在 Linux 下，这些共享库文件就是`.so` 文件，也就是 `Shared Object（一般我们也称之为动态链接库）`。这两大操作系统下的文件名后缀，一个用了“动态链接”的意思，另一个用了“共享”的意思，正好覆盖了两方面的含义。

![image-20230105141103120](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105141103120.png)

#### 6.2地址无关很重要，相对地址解烦恼

不过，要想要在程序运行的时候共享代码，也有一定的要求，就是这些机器码必须是“地址无关”的。也就是说，我们编译出来的共享库文件的指令代码，是`地址无关码（Position-Independent Code）`。换句话说就是，这段代码，无论加载在哪个内存地址，都能够正常执行。如果不是这样的代码，就是地址相关的代码。

你可以想想，大部分函数库其实都可以做到地址无关，因为它们都接受特定的输入，进行确定的操作，然后给出返回结果就好了。无论是实现一个向量加法，还是实现一个打印的函数，这些代码逻辑和输入的数据在内存里面的位置并不重要。

而常见的地址相关的代码，比如绝对地址代码（Absolute Code）、利用重定位表的代码等等，都是地址相关的代码。你回想一下我们之前讲过的重定位表。在程序链接的时候，我们就把函数调用后要跳转访问的地址确定下来了，`这意味着，如果这个函数加载到一个不同的内存地址，跳转就会失败。`

![image-20230105141353206](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105141353206.png)

`对于所有动态链接共享库的程序来讲，虽然我们的共享库用的都是同一段物理内存地址，但是在不同的应用程序里，它所在的虚拟内存地址是不同的。`我们没办法、也不应该要求动态链接同一个共享库的不同程序，必须把这个共享库所使用的虚拟内存地址变成一致。如果这样的话，我们写的程序就必须明确地知道内部的内存地址分配。

那么问题来了，我们要怎么样才能做到，动态共享库编译出来的代码指令，都是地址无关码呢？

动态代码库内部的变量和函数调用都很容易解决，我们只需要使用相对地址（Relative Address）就好了。各种指令中使用到的内存地址，给出的不是一个绝对的地址空间，而是一个相对于当前指令偏移量的内存地址。`因为整个共享库是放在一段连续的虚拟内存地址中的，无论装载到哪一段地址，不同指令之间的相对地址都是不变的。`

#### 6.3PLT 和 GOT，动态链接的解决方案

要实现动态链接共享库，也并不困难，和前面的静态链接里的符号表和重定向表类似，还是和前面一样，我们还是拿出一小段代码来看一看。

首先，`lib.h `定义了动态链接库的一个函数` show_me_the_money`。

```c
// lib.h
#ifndef LIB_H
#define LIB_H

void show_me_the_money(int money);

#endif
```

`lib.c` 包含了` lib.h `的实际实现。

```c
// lib.c
#include <stdio.h>

void show_me_the_money(int money)
{
    printf("Show me USD %d from lib.c \n", money);
}
```

然后，`show_me_poor.c` 调用了` lib `里面的函数。

```c
// show_me_poor.c
#include "lib.h"
int main()
{
    int money = 5;
    show_me_the_money(money);
}
```

最后，我们把 `lib.c` 编译成了一个动态链接库，也就是` .so `文件。

```shell
$ gcc lib.c -fPIC -shared -o lib.so
$ gcc -o show_me_poor show_me_poor.c ./lib.so
```

你可以看到，在编译的过程中，我们指定了一个 `-fPIC` 的参数。这个参数其实就是 `Position Independent Code` 的意思，也就是我们要把这个编译成一个地址无关代码。

然后，我们再通过 gcc 编译 show_me_poor 动态链接了 lib.so 的可执行文件。在这些操作都完成了之后，我们把 show_me_poor 这个文件通过 objdump 出来看一下。

```shell
$ objdump -d -M intel -S show_me_poor

……
0000000000400540 <show_me_the_money@plt-0x10>:
  400540:       ff 35 12 05 20 00       push   QWORD PTR [rip+0x200512]        # 600a58 <_GLOBAL_OFFSET_TABLE_+0x8>
  400546:       ff 25 14 05 20 00       jmp    QWORD PTR [rip+0x200514]        # 600a60 <_GLOBAL_OFFSET_TABLE_+0x10>
  40054c:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]

0000000000400550 <show_me_the_money@plt>:
  400550:       ff 25 12 05 20 00       jmp    QWORD PTR [rip+0x200512]        # 600a68 <_GLOBAL_OFFSET_TABLE_+0x18>
  400556:       68 00 00 00 00          push   0x0
  40055b:       e9 e0 ff ff ff          jmp    400540 <_init+0x28>
……
0000000000400676 <main>:
  400676:       55                      push   rbp
  400677:       48 89 e5                mov    rbp,rsp
  40067a:       48 83 ec 10             sub    rsp,0x10
  40067e:       c7 45 fc 05 00 00 00    mov    DWORD PTR [rbp-0x4],0x5
  400685:       8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
  400688:       89 c7                   mov    edi,eax
  40068a:       e8 c1 fe ff ff          call   400550 <show_me_the_money@plt>
  40068f:       c9                      leave  
  400690:       c3                      ret    
  400691:       66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]
  400698:       00 00 00 
  40069b:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]
……
```

我们还是只关心整个可执行文件中的一小部分内容。你应该可以看到，在 main 函数调用 show_me_the_money 的函数的时候，对应的代码是这样的：

```assembly
call   400550 <show_me_the_money@plt>
```

这里后面有一个` @plt `的关键字，代表了我们需要从 `PLT`，也就是程序链接表（Procedure Link Table）里面找要调用的函数。对应的地址呢，则是 400550 这个地址。

那当我们把目光挪到上面的 400550 这个地址，你又会看到里面进行了一次跳转，这个跳转指定的跳转地址，你可以在后面的注释里面可以看到，`GLOBAL_OFFSET_TABLE+0x18`。`这里的 GLOBAL_OFFSET_TABLE，就是我接下来要说的全局偏移表。`

```assembly
  400550:       ff 25 12 05 20 00       jmp    QWORD PTR [rip+0x200512]        # 600a68 <_GLOBAL_OFFSET_TABLE_+0x18>
```

在动态链接对应的共享库，我们在共享库的 data section 里面，保存了一张`全局偏移表（GOT，Global Offset Table）`。==虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的。==所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在我们加载一个个共享库的时候写进去的。

`不同的进程，调用同样的 lib.so，各自 GOT 里面指向最终加载的动态链接库里面的虚拟内存地址是不同的。`

这样，虽然不同的程序调用的同样的动态库，各自的内存地址是独立的，调用的又都是同一个动态库，但是不需要去修改动态库里面的代码所使用的地址，而是各个程序各自维护好自己的 GOT，能够找到对应的动态库就好了。

![image-20230105142555600](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105142555600.png)

我们的 GOT 表位于共享库自己的数据段里。`GOT 表在内存里和对应的代码段位置之间的偏移量，始终是确定的。这样，我们的共享库就是地址无关的代码，对应的各个程序只需要在物理内存里面加载同一份代码。`==而我们又要通过各个可执行程序在加载时，生成的各不相同的 GOT 表，来找到它需要调用到的外部变量和函数的地址。==

这是一个典型的、不修改代码，而是通过修改“地址数据”来进行关联的办法。它有点像我们在 C 语言里面用函数指针来调用对应的函数，并不是通过预先已经确定好的函数名称来调用，而是利用当时它在内存里面的动态地址来调用。

> 为什么要采用 PLT 和 GOT 两级跳转，直接用 GOT 有问题吗？
>
> PLT是为了做延迟绑定，如果函数没有实际被调用到，就不需要更新GOT里面的数值;因为很多动态装载的函数库都是不会被实际调用到的。 这个如果要深入细节可以看一下《程序员的自我修养》的7.4小结。

#### 6.4总结延伸

这一讲，我们终于在静态链接和程序装载之后，利用动态链接把我们的内存利用到了极致。同样功能的代码生成的共享库，我们只要在内存里面保留一份就好了。这样，我们不仅能够做到代码在开发阶段的复用，也能做到代码在运行阶段的复用。

实际上，在进行 Linux 下的程序开发的时候，我们一直会用到各种各样的动态链接库。`C 语言的标准库就在 1MB 以上。我们撰写任何一个程序可能都需要用到这个库，常见的 Linux 服务器里，/usr/bin 下面就有上千个可执行文件。如果每一个都把标准库静态链接进来的，几 GB 乃至几十 GB 的磁盘空间一下子就用出去了。`如果我们服务端的多进程应用要开上千个进程，几 GB 的内存空间也会一下子就用出去了。这个问题在过去计算机的内存较少的时候更加显著。

通过动态链接这个方式，可以说彻底解决了这个问题。就像共享单车一样，如果仔细经营，是一个很有社会价值的事情，但是如果粗暴地把它变成无限制地复制生产，给每个人造一辆，只会在系统内制造大量无用的垃圾。

过去的这五讲里，我们已经把程序怎么从源代码变成指令、数据，并装载到内存里面，由 CPU 一条条执行下去的过程讲完了。希望你能有所收获，对于一个程序是怎么跑起来的，有了一个初步的认识。

#### 6.5推荐阅读

想要更加深入地了解动态链接，我推荐你可以读一读《程序员的自我修养：链接、装载和库》的第 7 章，里面深入地讲解了，动态链接里程序内的数据布局和对应数据的加载关系。

#### 6.6课后思考

像动态链接这样通过修改“地址数据”来进行间接跳转，去调用一开始不能确定位置代码的思路，你在应用开发中使用过吗？

Java多态的应用、动态代理。

### 7.二进制编码：“手持两把锟斤拷，口中疾呼烫烫烫”？

上算法和数据结构课的时候，老师们都会和你说，`程序 = 算法 + 数据结构`。如果对应到组成原理或者说硬件层面，`算法就是我们前面讲的各种计算机指令，数据结构就对应我们接下来要讲的二进制数据`。

众所周知，现代计算机都是用 0 和 1 组成的二进制，来表示所有的信息。前面几讲的程序指令用到的机器码，也是使用二进制表示的；我们存储在内存里面的字符串、整数、浮点数也都是用二进制表示的。万事万物在计算机里都是 0 和 1，所以呢，搞清楚各种数据在二进制层面是怎么表示的，是我们必备的一课。

大部分教科书都会详细地从整数的二进制表示讲起，相信你在各种地方都能看到对应的材料，所以我就不再啰啰嗦嗦地讲这个了，只会快速地浏览一遍整数的二进制表示。

然后呢，我们重点来看一看，大家在实际应用中最常遇到的问题，也就是文本字符串是怎么表示成二进制的，特别是我们会遇到的乱码究竟是怎么回事儿。我们平时在开发的时候，所说的 Unicode 和 UTF-8 之间有什么关系。理解了这些，相信以后遇到任何乱码问题，你都能手到擒来了。

#### 7.1理解二进制的“逢二进一”

二进制和我们平时用的十进制，其实并没有什么本质区别，只是平时我们是“逢十进一”，这里变成了“逢二进一”而已。每一位，相比于十进制下的 0～9 这十个数字，我们只能用 0 和 1 这两个数字。

任何一个十进制的整数，都能通过二进制表示出来。把一个二进制数，对应到十进制，非常简单，就是把从右到左的第 N 位，乘上一个 2 的 N 次方，然后加起来，就变成了一个十进制数。当然，既然二进制是一个面向程序员的“语言”，这个从右到左的位置，自然是从 0 开始的。比如 0011 这个二进制数，对应的十进制表示，就是 0×2^3^+0×2^2^+1×2^1^+1×2^0^=3，代表十进制的 3。

对应地，如果我们想要把一个十进制的数，转化成二进制，使用`短除法`就可以了。`也就是，把十进制数除以 2 的余数，作为最右边的一位。然后用商继续除以 2，把对应的余数紧靠着刚才余数的右侧，这样递归迭代，直到商为 0 就可以了。`

比如，我们想把 13 这个十进制数，用短除法转化成二进制，需要经历以下几个步骤：

![image-20230105190257166](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105190257166.png)

因此，对应的二进制数，就是 1101。

刚才我们举的例子都是正数，对于负数来说，情况也是一样的吗？我们可以把一个数最左侧的一位，当成是对应的正负号，比如 0 为正数，1 为负数，这样来进行标记。

这样，一个 4 位的二进制数， 0011 就表示为 +3。而 1011 最左侧的第一位是 1，所以它就表示 -3。这个其实就是整数的`原码表示法`。==原码表示法有一个很直观的缺点就是，0 可以用两个不同的编码来表示，1000 代表 0， 0000 也代表 0。==习惯万事一一对应的程序员看到这种情况，必然会被“逼死”。

于是，我们就有了另一种表示方法。我们仍然通过最左侧第一位的 0 和 1，来判断这个数的正负。但是，我们不再把这一位当成单独的符号位，在剩下几位计算出的十进制前加上正负号，而是`在计算整个二进制值的时候，在左侧最高位前面加个负号`。

比如，一个 4 位的二进制补码数值 1011，转换成十进制，就是 −1×2^3^+0×2^2^+1×2^1^+1×2^0^=−5。`如果最高位是 1，这个数必然是负数；最高位是 0，必然是正数`。==并且，只有 0000 表示 0，1000 在这样的情况下表示 -8。一个 4 位的二进制数，可以表示从 -8 到 7 这 16 个整数，不会白白浪费一位。==

==当然更重要的一点是，用补码来表示负数，使得我们的整数相加变得很容易，不需要做任何特殊处理，只是把它当成普通的二进制相加，就能得到正确的结果。==

我们简单一点，拿一个 4 位的整数来算一下，比如 -5 + 1 = -4，-5 + 6 = 1。我们各自把它们转换成二进制来看一看。如果它们和无符号的二进制整数的加法用的是同样的计算方式，这也就意味着它们是同样的电路。

![image-20230105190616226](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105190616226.png)

#### 7.2字符串的表示，从编码到数字

不仅数值可以用二进制表示，字符乃至更多的信息都能用二进制表示。最典型的例子就是`字符串（Character String）`。最早计算机只需要使用英文字符，加上数字和一些特殊符号，然后用 8 位的二进制，就能表示我们日常需要的所有字符了，这个就是我们常常说的 `ASCII 码`（American Standard Code for Information Interchange，美国信息交换标准代码）。

![image-20230105190830358](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105190830358.png)

ASCII 码就好比一个字典，用 8 位二进制中的 128 个不同的数，映射到 128 个不同的字符里。比如，小写字母 a 在 ASCII 里面，就是第 97 个，也就是二进制的 0110 0001，对应的十六进制表示就是 61。而大写字母 A，就是第 65 个，也就是二进制的 0100 0001，对应的十六进制表示就是 41。

==在 ASCII 码里面，数字 9 不再像整数表示法里一样，用 0000 1001 来表示，而是用 0011 1001 来表示。字符串 15 也不是用 0000 1111 这 8 位来表示，而是变成两个字符 1 和 5 连续放在一起，也就是 0011 0001 和 0011 0101，需要用两个 8 位来表示。==

==我们可以看到，最大的 32 位整数，就是 2147483647。如果用整数表示法，只需要 32 位就能表示了。但是如果用字符串来表示，一共有 10 个字符，每个字符用 8 位的话，需要整整 80 位。比起整数表示法，要多占很多空间。==

这也是为什么，很多时候我们在存储数据的时候，要采用二进制序列化这样的方式，而不是简单地把数据通过 CSV 或者 JSON，这样的文本格式存储来进行序列化。`不管是整数也好，浮点数也好，采用二进制序列化会比存储文本省下不少空间。`

ASCII 码只表示了 128 个字符，一开始倒也堪用，毕竟计算机是在美国发明的。然而随着越来越多的不同国家的人都用上了计算机，想要表示譬如中文这样的文字，128 个字符显然是不太够用的。于是，计算机工程师们开始各显神通，给自己国家的语言创建了对应的`字符集（Charset）`和`字符编码（Character Encoding）`。

`字符集，表示的可以是字符的一个集合。`比如“中文”就是一个字符集，不过这样描述一个字符集并不准确。想要更精确一点，我们可以说，“第一版《新华字典》里面出现的所有汉字”，这是一个字符集。这样，我们才能明确知道，一个字符在不在这个集合里面。比如，我们日常说的 Unicode，其实就是一个字符集，包含了 150 种语言的 14 万个不同的字符。

`而字符编码则是对于字符集里的这些字符，怎么一一用二进制表示出来的一个字典。`==我们上面说的 Unicode，就可以用 UTF-8、UTF-16，乃至 UTF-32 来进行编码，存储成二进制。==所以，有了 Unicode，其实我们可以用不止 UTF-8 一种编码形式，我们也可以自己发明一套 GT-32 编码，比如就叫作 Geek Time 32 好了。只要别人知道这套编码规则，就可以正常传输、显示这段代码。

![image-20230105191155235](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105191155235.png)

`同样的文本，采用不同的编码存储下来。如果另外一个程序，用一种不同的编码方式来进行解码和展示，就会出现乱码。`这就好像两个军队用密语通信，如果用错了密码本，那看到的消息就会不知所云。在中文世界里，最典型的就是“手持两把锟斤拷，口中疾呼烫烫烫”的典故。

我曾经听说过这么一个笑话，没有经验的同学，在看到程序输出“烫烫烫”的时候，以为是程序让 CPU 过热发出报警，于是尝试给 CPU 降频来解决问题。

既然今天要彻底搞清楚编码知识，我们就来弄清楚“锟斤拷”和“烫烫烫”的来龙去脉。

![image-20230105191249034](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105191249034.png)

首先，“锟斤拷”的来源是这样的。`如果我们想要用 Unicode 编码记录一些文本，特别是一些遗留的老字符集内的文本，但是这些字符在 Unicode 中可能并不存在。于是，Unicode 会统一把这些字符记录为 U+FFFD 这个编码。如果用 UTF-8 的格式存储下来，就是\xef\xbf\xbd。如果连续两个这样的字符放在一起，\xef\xbf\xbd\xef\xbf\xbd，这个时候，如果程序把这个字符，用 GB2312 的方式进行 decode，就会变成“锟斤拷”。`这就好比我们用 GB2312 这本密码本，去解密别人用 UTF-8 加密的信息，自然没办法读出有用的信息。

`而“烫烫烫”，则是因为如果你用了 Visual Studio 的调试器，默认使用 MBCS 字符集。“烫”在里面是由 0xCCCC 来表示的，而 0xCC 又恰好是未初始化的内存的赋值。于是，在读到没有赋值的内存地址或者变量的时候，电脑就开始大叫“烫烫烫”了。`

了解了这些原理，相信你未来在遇到中文的编码问题的时候，可以做到“手中有粮，心中不慌”了。

#### 7.3总结延伸

到这里，相信你发现，我们可以用二进制编码的方式，表示任意的信息。只要建立起字符集和字符编码，并且得到大家的认同，我们就可以在计算机里面表示这样的信息了。所以说，如果你有心，要发明一门自己的克林贡语并不是什么难事。

不过，光是明白怎么把数值和字符在逻辑层面用二进制表示是不够的。我们在计算机组成里面，关心的不只是数值和字符的逻辑表示，更要弄明白，在硬件层面，这些数值和我们一直提的晶体管和电路有什么关系。下一讲，我就会为你揭开神秘的面纱。我会从时钟和触发器讲起，最终让你明白，计算机里的加法，是如何通过电路来实现的。

#### 7.4推荐阅读

关于二进制和编码，我推荐你读一读《编码：隐匿在计算机软硬件背后的语言》。从电报机到计算机，这本书讲述了很多计算设备的历史故事，当然，也包含了二进制及其背后对应的电路原理。

#### 7.5课后思考

你肯定会计算十进制整数的加减法，二进制的加减法也是一样的。如果二进制的加法中，有数是负数的时候该怎么处理呢？我们今天讲了补码的表示形式，如果这个负数是原码表示的，又应该如何处理？如果是补码表示的呢？请你用二进制加法试着算一算，-5+4=-1，通过原码和补码是如何进行的？

- 原码表示法：-5表示为1101，4表示为0100，-5+4 = [1101]原码+[0100]原码=[1010]反码+[0100]反码=[1011]补码+[0100]补码=[1111]补码= -2^3^ + 2^2^ + 2^1^ + 2^0^ = -1

- 补码表示法：-5表示为1011，4表示为0100，-5+4 = [1011]补码+[0100]补码=[1111]补码= -2^3^ + 2^2^ + 2^1^ + 2^0^ = -1

### 8.理解电路：从电报机到门电路，我们如何做到“千里传信”？

我们前面讲过机器指令，你应该知道，所有最终执行的程序其实都是使用“0”和“1”这样的二进制代码来表示的。上一讲里，我也向你展示了，对应的整数和字符串，其实也是用“0”和“1”这样的二进制代码来表示的。

那么你可能要问了，我知道了这个有什么用呢？毕竟我们人用纸和笔来做运算，都是用十进制，直接用十进制和我们最熟悉的符号不是最简单么？为什么计算机里我们最终要选择二进制呢？

这一讲，我和你一起来看看，计算机在硬件层面究竟是怎么表示二进制的，以此你就会明白，为什么计算机会选择二进制。

#### 8.1从信使到电报，我们怎么做到“千里传书”？

马拉松的故事相信你听说过。公元前 490 年，在雅典附近的马拉松海边，发生了波斯和希腊之间的希波战争。雅典和斯巴达领导的希腊联军胜利之后，雅典飞毛腿菲迪皮德斯跑了历史上第一个马拉松，回雅典报喜。这个时候，人们在远距离报信的时候，采用的是派人跑腿，传口信或者送信的方式。

但是，这样靠人传口信或者送信的方式，实在是太慢了。在军事用途中，信息能否更早更准确地传递出去经常是事关成败的大事。所以我们看到中国古代的军队有“击鼓进军”和“鸣金收兵”，通过打鼓和敲钲发出不同的声音，来传递军队的号令。

如果我们把军队当成一台计算机，那“金”和“鼓”就是这台计算机的“1”和“0”。我们可以通过不同的编码方式，来指挥这支军队前进、后退、转向、追击等等。

“金”和“鼓”比起跑腿传口信，固然效率更高了，但是能够传递的范围还是非常有限，超出个几公里恐怕就听不见了。于是，人们发明了更多能够往更远距离传信的方式，比如海上的灯塔、长城上的烽火台。因为光速比声速更快，传的距离也可以更远。

![image-20230105193849686](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105193849686.png)

但是，这些传递信息的方式都面临一个问题，就是受限于只有“1”和“0”这两种信号，不能传递太复杂的信息，那电报的发明就解决了这个问题。

从信息编码的角度来说，金、鼓、灯塔、烽火台类似电报的二进制编码。电报传输的信号有两种，一种是短促的点信号（dot 信号），一种是长一点的划信号（dash 信号）。我们把“点”当成“1”，把“划”当成“0”。这样一来，我们的电报信号就是另一种特殊的二进制编码了。电影里最常见的电报信号是“SOS”，这个信号表示出来就是 “点点点划划划点点点”。

比起灯塔和烽火台这样的设备，电报信号有两个明显的优势。`第一，信号的传输距离迅速增加。因为电报本质上是通过电信号来进行传播的，所以从输入信号到输出信号基本上没有延时。第二，输入信号的速度加快了很多。`电报机只有一个按钮，按下就是输入信号，按的时间短一点，就是发出了一个“点”信号；按的时间长一些，就是一个“划”信号。只要一个手指，就能快速发送电报。

![image-20230105193945609](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105193945609.png)

而且，制造一台电报机也非常容易。电报机本质上就是一个`“蜂鸣器 + 长长的电线 + 按钮开关”`。蜂鸣器装在接收方手里，开关留在发送方手里。双方用长长的电线连在一起。当按钮开关按下的时候，电线的电路接通了，蜂鸣器就会响。短促地按下，就是一个短促的点信号；按的时间稍微长一些，就是一个稍长的划信号。

![image-20230105194028834](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105194028834.png)

#### 8.2理解继电器，给跑不动的信号续一秒

有了电报机，只要铺设好电报线路，就可以传输我们需要的讯息了。但是这里面又出现了一个新的挑战，就是`随着电线的线路越长，电线的电阻就越大。当电阻很大，而电压不够的时候，即使你按下开关，蜂鸣器也不会响`。

你可能要说了，我们可以提高电压或者用更粗的电线，使得电阻更小，这样就可以让整个线路铺得更长一些。但是这个再长，也没办法从北京铺设到上海吧。要想从北京把电报发到上海，我们还得想些别的办法。

对于电报来说，电线太长了，使得线路接通也没有办法让蜂鸣器响起来。那么，我们就不要一次铺太长的线路，而把一小段距离当成一个线路。我们也可以跟驿站建立一个小电报站，在小电报站里面安排一个电报员。他听到上一个小电报站发来的信息，然后原样输入，发到下一个电报站去。这样，我们的信号就可以一段段传输下去，而不会因为距离太长，导致电阻太大，没有办法成功传输信号。为了能够实现这样`接力传输信号`，在电路里面，工程师们造了一个叫作`继电器（Relay）`的设备。

![image-20230105194133906](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105194133906.png)

事实上，这个过程中，我们需要在每一阶段`原样传输信号`，所以你可以想想，我们是不是可以设计一个设备来代替这个电报员？相比使用人工听蜂鸣器的声音，来重复输入信号，利用电磁效应和磁铁，来实现这个事情会更容易。

我们把原先用来输出声音的蜂鸣器，换成一段环形的螺旋线圈，让电路封闭通上电。因为电磁效应，这段螺旋线圈会产生一个带有磁性的电磁场。我们原本需要输入的按钮开关，就可以用一块磁力稍弱的磁铁把它设在“关”的状态。这样，按下上一个电报站的开关，螺旋线圈通电产生了磁场之后，磁力就会把开关“吸”下来，接通到下一个电报站的电路。

如果我们在中间所有小电报站都用这个`“螺旋线圈 + 磁性开关”`的方式，来替代蜂鸣器和普通开关，而只在电报的始发和终点用普通的开关和蜂鸣器，我们就有了一个拆成一段一段的电报线路，接力传输电报信号。这样，我们就不需要中间安排人力来听打电报内容，也不需要解决因为线缆太长导致的电阻太大或者电压不足的问题了。我们只要在终点站安排电报员，听写最终的电报内容就可以了。这样是不是比之前更省事了？

事实上，继电器还有一个名字就叫作`电驿`，这个“驿”就是驿站的驿，可以说非常形象了。这个接力的策略不仅可以用在电报中，在通信类的科技产品中其实都可以用到。比如说，你在家里用 WiFi，如果你的屋子比较大，可能某些房间的信号就不好。你可以选用支持“中继”的 WiFi 路由器，在信号衰减的地方，增加一个 WiFi 设备，接收原来的 WiFi 信号，再重新从当前节点传输出去。这种中继对应的英文名词和继电器是一样的，也叫 Relay。

再比如说，我们现在互联网使用的光缆，是用光信号来传输数据。随着距离的增长、反射次数的增加，信号也会有所衰减，我们同样要每隔一段距离，来增加一个用来重新放大信号的中继。

有了继电器之后，我们不仅有了一个能够接力传输信号的方式，更重要的是，和输入端通过开关的“开”和“关”来表示“1”和“0”一样，我们在输出端也能表示“1”和“0”了。

输出端的作用，不仅仅是通过一个蜂鸣器或者灯泡，提供一个供人观察的输出信号，`通过“螺旋线圈 + 磁性开关”，使得我们有“开”和“关”这两种状态，这个“开”和“关”表示的“1”和“0”，还可以作为后续线路的输入信号`，让我们开始可以通过最简单的电路，来组合形成我们需要的逻辑。

> 通过这些线圈和开关，我们也可以很容易地创建出` “与（AND）”“或（OR）”“非（NOT）”`这样的逻辑。我们在输入端的电路上，提供`串联的两个开关`，只有两个开关都打开，电路才接通，输出的开关也才能接通，这其实就是模拟了计算机里面的`“与”`操作。
>
> 我们在输入端的电路，提供`两条独立的线路`到输出端，两条线路上各有一个开关，那么任何一个开关打开了，到输出端的电路都是接通的，这其实就是模拟了计算机中的`“或”`操作。
>
> 当我们把输出端的`“螺旋线圈 + 磁性开关”的组合，从默认关掉，只有通电有了磁场之后打开，换成默认是打开通电的，只有通电之后才关闭`，我们就得到了一个计算机中的`“非”`操作。输出端开和关正好和输入端相反。这个在数字电路中，也叫作反向器（Inverter）。

![image-20230105194555671](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105194555671.png)

与、或、非的电路都非常简单，要想做稍微复杂一点的工作，我们需要很多电路的组合。不过，这也彰显了现代计算机体系中一个重要的思想，就是`通过分层和组合，逐步搭建起更加强大的功能`。

回到我们前面看的电报机原型，虽然一个按钮开关的电报机很“容易”操作，但是却不“方便”操作。因为电报员要熟记每一个字母对应的摩尔斯电码，并且需要快速按键来进行输入，一旦输错很难纠正。但是，==因为电路之间可以通过与、或、非组合完成更复杂的功能，我们完全可以设计一个和打字机一样的电报机，每按下一个字母按钮，就会接通一部分电路，然后把这个字母的摩尔斯电码输出出去。==

虽然在电报机时代，我们没有这么做，但是在计算机时代，我们其实就是这样做的。我们不再是给计算机“0”和“1”，而是通过千万个晶体管组合在一起，最终使得我们可以用“高级语言”，指挥计算机去干什么。

#### 8.3总结延伸

可以说，电报是现代计算机的一个最简单的原型。它和我们现在使用的现代计算机有很多相似之处。我们通过电路的“开”和“关”，来表示“1”和“0”。就像晶体管在不同的情况下，表现为导电的“1”和绝缘的“0”的状态。

我们通过电报机这个设备，看到了如何通过“螺旋线圈 + 开关”，来构造基本的逻辑电路，我们也叫门电路。一方面，我们可以通过继电器或者中继，进行长距离的信号传输。另一方面，我们也可以通过设置不同的线路和开关状态，实现更多不同的信号表示和处理方式，这些线路的连接方式其实就是我们在数字电路中所说的门电路。而这些门电路，也是我们创建 CPU 和内存的基本逻辑单元。我们的各种对于计算机二进制的“0”和“1”的操作，其实就是来自于门电路，叫作组合逻辑电路。

#### 8.4推荐阅读

《编码：隐匿在计算机软硬件背后的语言》的第 6～11 章，是一个很好的入门材料，可以帮助你深入理解数字电路，值得你花时间好好读一读。

#### 8.5课后思考

除了与、或、非之外，还有很多基础的门电路，比如“异或（XOR）门”。你可以想一想，试着搜索一些资料，设计一个异或门的电路。

==A^B = ((\~A)&B)|(A&(\~B))==

### 9.加法器：如何像搭乐高一样搭电路（上）？

上一讲，我们看到了如何通过电路，在计算机硬件层面设计最基本的单元，门电路。我给你看的门电路非常简单，只能做简单的 “`与（AND）`”“`或（OR）`”“`NOT（非）`”和“`异或（XOR）`”，这样`最基本的单比特逻辑运算`。下面这些门电路的标识，你需要非常熟悉，后续的电路都是由这些门电路组合起来的。

![image-20230105201837353](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105201837353.png)

这些基本的门电路，是我们计算机硬件端的最基本的“积木”，就好像乐高积木里面最简单的小方块。看似不起眼，但是把它们组合起来，最终可以搭出一个星球大战里面千年隼这样的大玩意儿。我们今天包含十亿级别晶体管的现代 CPU，都是由这样一个一个的门电路组合而成的。

#### 9.1异或门和半加器

我们看到的`基础门电路，输入都是两个单独的 bit，输出是一个单独的 bit`。如果我们要对 2 个 8 位（bit）的数，计算与、或、非这样的简单逻辑运算，其实很容易。==只要连续摆放 8 个开关，来代表一个 8 位数。这样的两组开关，从左到右，上下单个的位开关之间，都统一用“与门”或者“或门”连起来，就是两个 8 位数的 AND 或者 OR 的运算了。==

比起 AND 或者 OR 这样的电路外，要想实现整数的加法，就需要组建稍微复杂一点儿的电路了。

我们先回归一个最简单的 8 位的无符号整数的加法。这里的“无符号”，表示我们并不需要使用补码来表示负数。无论高位是“0”还是“1”，这个整数都是一个正数。

我们很直观就可以想到，要表示一个 8 位数的整数，简单地用 8 个 bit，也就是 8 个像上一讲的电路开关就好了。那 2 个 8 位整数的加法，就是 2 排 8 个开关。加法得到的结果也是一个 8 位的整数，所以又需要 1 排 8 位的开关。要想实现加法，我们就要看一下，通过什么样的门电路，能够连接起加数和被加数，得到最后期望的和。

![image-20230105202017167](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105202017167.png)

要做到这一点，我们先来看看，我们人在计算加法的时候一般会怎么操作。二进制的加法和十进制没什么区别，所以我们一样可以用列竖式来计算。我们仍然是从右到左，一位一位进行计算，只是把从逢 10 进 1 变成逢 2 进 1。

![image-20230105202037200](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105202037200.png)

你会发现，其实计算一位数的加法很简单。我们先就看最简单的个位数。输入一共是 4 种组合，00、01、10、11。得到的结果，也不复杂。

一方面，我们需要知道，加法计算之后的个位是什么，在输入的两位是 00 和 11 的情况下，对应的输出都应该是 0；在输入的两位是 10 和 01 的情况下，输出都是 1。`结果你会发现，这个输入和输出的对应关系，其实就是我在上一讲留给你的思考题里面的“异或门（XOR）”。`

讲与、或、非门的时候，我们很容易就能和程序里面的“AND（通常是 & 符号）”“ OR（通常是 | 符号）”和“ NOT（通常是 ! 符号）”对应起来。可能你没有想过，为什么我们会需要“异或（XOR）”，这样一个在逻辑运算里面没有出现的形式，作为一个基本电路。`其实，异或门就是一个最简单的整数加法，所需要使用的基本门电路。`

算完个位的输出还不算完，输入的两位都是 11 的时候，我们还需要向更左侧的一位进行进位。`那这个就对应一个与门，也就是有且只有在加数和被加数都是 1 的时候，我们的进位才会是 1。`

所以，通过一个异或门计算出个位，通过一个与门计算出是否进位，我们就通过电路算出了一个一位数的加法。于是，我们把两个门电路打包，给它取一个名字，就叫作`半加器（Half Adder）`。

![image-20230105202204940](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105202204940.png)

#### 9.2全加器

你肯定很奇怪，为什么我们给这样的电路组合，取名叫半加器（Half Adder）？莫非还有一个全加器（Full Adder）么？你猜得没错。`半加器可以解决个位的加法问题`，但是如果放到二位上来说，就不够用了。我们这里的竖式是个二进制的加法，所以如果从右往左数，第二列不是十位，我称之为“二位”。对应的再往左，就应该分别是四位、八位。

二位用一个半加器不能计算完成的原因也很简单。因为二位除了一个加数和被加数之外，还需要加上来自个位的进位信号，一共需要三个数进行相加，才能得到结果。但是我们目前用到的，无论是最简单的门电路，还是用两个门电路组合而成的半加器，输入都只能是两个 bit，也就是两个开关。那我们该怎么办呢？

实际上，解决方案也并不复杂。`我们用两个半加器和一个或门，就能组合成一个全加器。`第一个半加器，我们用和个位的加法一样的方式，得到是否进位 X 和对应的二个数加和后的结果 Y，这样两个输出。然后，我们把这个加和后的结果 Y，和个位数相加后输出的进位信息 U，再连接到一个半加器上，就会再拿到一个是否进位的信号 V 和对应的加和后的结果 W。

![image-20230105202321317](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105202321317.png)

这个 W 就是我们在二位上留下的结果。我们把两个半加器的进位输出，作为一个或门的输入连接起来，只要两次加法中任何一次需要进位，那么在二位上，我们就会向左侧的四位进一位。因为一共只有三个 bit 相加，即使 3 个 bit 都是 1，也最多会进一位。

==这样，通过两个半加器和一个或门，我们就得到了一个，能够接受进位信号、加数和被加数，这样三个数组成的加法。这就是我们需要的全加器。==

有了全加器，我们要进行对应的两个 8 bit 数的加法就很容易了。我们只要把 8 个全加器串联起来就好了。个位的全加器的进位信号作为二位全加器的输入信号，二位全加器的进位信号再作为四位的全加器的进位信号。这样一层层串接八层，我们就得到了一个支持 8 位数加法的算术单元。如果要扩展到 16 位、32 位，乃至 64 位，都只需要多串联几个输入位和全加器就好了。

![image-20230105202442372](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105202442372.png)

`唯一需要注意的是，对于这个全加器，在个位，我们只需要用一个半加器，或者让全加器的进位输入始终是 0。`因为个位没有来自更右侧的进位。==而最左侧的一位输出的进位信号，表示的并不是再进一位，而是表示我们的加法是否溢出了。==

这也是很有意思的一点。以前我自己在了解二进制加法的时候，一直有这么个疑问，既然 int 这样的 16 位的整数加法，结果也是 16 位数，那我们怎么知道加法最终是否溢出了呢？因为结果也只存得下加法结果的 16 位数。我们并没有留下一个第 17 位，来记录这个加法的结果是否溢出。

看到全加器的电路设计，相信你应该明白，==在整个加法器的结果中，我们其实有一个电路的信号，会标识出加法的结果是否溢出。我们可以把这个对应的信号，输出给到硬件中其他标志位里，让我们的计算机知道计算的结果是否溢出。==而现代计算机也正是这样做的。这就是为什么你在撰写程序的时候，能够知道你的计算结果是否溢出在硬件层面得到的支持。

#### 9.3总结延伸

相信到这里，你应该已经体会到了，通过门电路来搭建算术计算的一个小功能，就好像搭乐高积木一样。

我们用两个门电路，搭出一个半加器，就好像我们拿两块乐高，叠在一起，变成一个长方形的乐高，这样我们就有了一个新的积木组件，柱子。我们再用两个柱子和一个长条的积木组合一下，就变成一个积木桥。然后几个积木桥串接在一起，又成了积木楼梯。

当我们想要搭建一个摩天大楼，我们需要很多很多楼梯。但是这个时候，我们已经不再关注最基础的一节楼梯是怎么用一块块积木搭建起来的。这其实就是计算机中，无论软件还是硬件中一个很重要的设计思想，`分层`。

![image-20230105202617425](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105202617425.png)

从简单到复杂，我们一层层搭出了拥有更强能力的功能组件。在上面的一层，我们只需要考虑怎么用下一层的组件搭建出自己的功能，而不需要下沉到更低层的其他组件。就像你之前并没有深入学习过计算机组成原理，一样可以直接通过高级语言撰写代码，实现功能。

在硬件层面，我们通过门电路、半加器、全加器一层层搭出了加法器这样的功能组件。我们把这些用来做算术逻辑计算的组件叫作 ALU，也就是算术逻辑单元。`当进一步打造强大的 CPU 时，我们不会再去关注最细颗粒的门电路，只需要把门电路组合而成的 ALU，当成一个能够完成基础计算的黑盒子就可以了。`

以此类推，后面我们讲解 CPU 的设计和数据通路的时候，我们以 ALU 为一个基础单元来解释问题，也就够了。

#### 9.4补充阅读

出于性能考虑，实际 CPU 里面使用的加法器，比起我们今天讲解的电路还有些差别，会更复杂一些。真实的加法器，使用的是一种叫作超前进位加法器的东西。你可以找到北京大学在 Coursera 上开设的《计算机组成》课程中的 Video-306 “加法器优化”一节，了解一下超前进位加法器的实现原理，以及我们为什么要使用它。

#### 9.5课后思考

这一讲，我给你详细讲解了无符号数的加法器是怎么通过电路搭建出来的。那么，如果是使用补码表示的有符号数，这个加法器是否可以实现正数加负数这样的运算呢？如果不行，我们应该怎么搭建对应的电路呢？

补码表示的有符号数不能使用无符号数的加法器运算，可以看出的是，`当两个正数或者两个负数相加可能会产生上溢或者下溢`（正数和负数相加不必考虑溢出问题），检测的方法也很简单，利用`异或器检测符号位`，如果`符号位相同`即异或结果为0，需要检测`相加后结果的符号位是否发生了改变`，如果符号位从0变成1（两个正数相加结果却是负数）则发生上溢，符号位从1变成0（两个负数相加结果却是正数）则发生下溢。

### 10.乘法器：如何像搭乐高一样搭电路（下）？

和学习小学数学一样，学完了加法之后，我们自然而然就要来学习乘法。既然是退回到小学，我们就把问题搞得简单一点，先来看两个 4 位数的乘法。这里的 4 位数，当然还是一个二进制数。我们是人类而不是电路，自然还是用列竖式的方式来进行计算。

十进制中的 13 乘以 9，计算的结果应该是 117。我们通过转换成二进制，然后列竖式的办法，来看看整个计算的过程是怎样的。

![image-20230105210611944](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105210611944.png)

#### 10.1顺序乘法的实现过程

从列出竖式的过程中，你会发现，二进制的乘法有个很大的优点，就是这个过程你不需要背九九乘法口诀表了。因为单个位置上，乘数只能是 0 或者 1，所以`实际的乘法，就退化成了位移和加法。`

在 13×9 这个例子里面，被乘数 13 表示成二进制是 1101，乘数 9 在二进制里面是 1001。最右边的个位是 1，所以个位乘以被乘数，就是把被乘数 1101 复制下来。因为二位和四位都是 0，所以乘以被乘数都是 0，那么保留下来的都是 0000。乘数的八位是 1，我们仍然需要把被乘数 1101 复制下来。不过这里和个位位置的单纯复制有一点小小的差别，那就是要把复制好的结果向左侧移三位，然后`把这四个（个位、二位、四位、八位）单独进行乘法加位移的结果，再加起来，我们就得到了最终的计算结果`。

对应到我们之前讲的数字电路和 ALU，你可以看到，最后一步的加法，我们可以用上一讲的加法器来实现。乘法因为只有“0”和“1”两种情况，所以可以做成输入输出都是 4 个开关，中间用 1 个开关，同时来控制这 8 个开关的方式，这就实现了二进制下的单位的乘法。

![image-20230105211026176](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105211026176.png)

至于位移也不麻烦，我们只要不是直接连线，把正对着的开关之间进行接通，而是斜着错开位置去接就好了。如果要左移一位，就错开一位接线；如果要左移两位，就错开两位接线。

![image-20230105211045724](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105211045724.png)

这样，你会发现，我们并不需要引入任何新的、更复杂的电路，仍然用最基础的电路，只要用不同的接线方式，就能够实现一个“列竖式”的乘法。而且，因为二进制下，只有 0 和 1，也就是开关的开和闭这两种情况，所以我们的计算机也不需要去“背诵”九九乘法口诀表，不需要单独实现一个更复杂的电路，就能够实现乘法。

为了节约一点开关，也就是晶体管的数量。实际上，像 13×9 这样两个四位数的乘法，我们不需要把四次单位乘法的结果，用四组独立的开关单独都记录下来，然后再把这四个数加起来。因为这样做，需要很多组开关，如果我们计算一个 32 位的整数乘法，就要 32 组开关，太浪费晶体管了。`如果我们顺序地来计算，只需要一组开关就好了。`

我们先拿乘数最右侧的个位乘以被乘数，然后把结果写入用来存放计算结果的开关里面，然后，把被乘数左移一位，把乘数右移一位，仍然用乘数去乘以被乘数，然后把结果加到刚才的结果上。反复重复这一步骤，直到不能再左移和右移位置。`这样，乘数和被乘数就像两列相向而驶的列车，仅仅需要简单的加法器、一个可以左移一位的电路和一个右移一位的电路，就能完成整个乘法。`

![image-20230105211308525](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105211308525.png)

你看这里画的乘法器硬件结构示意图。`这里的控制测试，其实就是通过一个时钟信号，来控制左移、右移以及重新计算乘法和加法的时机。`我们还是以计算 13×9，也就是二进制的 1101×1001 来具体看。

![image-20230105211359116](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105211359116.png)

这个计算方式虽然节约电路了，但是也有一个很大的缺点，那就是慢。

你应该很容易就能发现，在这个乘法器的实现过程里，我们其实就是把乘法展开，变成了“`加法 + 位移`”来实现。我们用的是 4 位数，所以要进行 4 组“位移 + 加法”的操作。而且这 4 组操作还不能同时进行。`因为下一组的加法要依赖上一组的加法后的计算结果，下一组的位移也要依赖上一组的位移的结果。这样，整个算法是“顺序”的，每一组加法或者位移的运算都需要一定的时间。`

所以，最终这个乘法的计算速度，其实和我们要计算的数的位数有关。比如，这里的 4 位，就需要 4 次加法。而我们的现代 CPU 常常要用 32 位或者是 64 位来表示整数，那么对应就需要 32 次或者 64 次加法。比起 4 位数，要多花上 8 倍乃至 16 倍的时间。

换个我们在算法和数据结构中的术语来说就是，`这样的一个顺序乘法器硬件进行计算的时间复杂度是 O(N)`。这里的 N，就是乘法的数里面的位数。

#### 10.2并行加速方法

那么，我们有没有办法，把时间复杂度上降下来呢？研究数据结构和算法的时候，我们总是希望能够把 O(N) 的时间复杂度，降低到 O(logN)。办法还真的有。和软件开发里面改算法一样，在涉及 CPU 和电路的时候，我们可以改电路。

32 位数虽然是 32 次加法，但是我们可以让很多加法同时进行。`回到这一讲开始，我们把位移和乘法的计算结果加到中间结果里的方法，32 位整数的乘法，其实就变成了 32 个整数相加。`

前面顺序乘法器硬件的实现办法，就好像体育比赛里面的单败淘汰赛。只有一个擂台会存下最新的计算结果。每一场新的比赛就来一个新的选手，实现一次加法，实现完了剩下的还是原来那个守擂的，直到其余 31 个选手都上来比过一场。如果一场比赛需要一天，那么一共要比 31 场，也就是 31 天。

![image-20230105211616523](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105211616523.png)

加速的办法，就是把比赛变成像世界杯足球赛那样的淘汰赛，32 个球队捉对厮杀，同时开赛。这样一天一下子就淘汰了 16 支队，也就是说，32 个数两两相加后，你可以得到 16 个结果。后面的比赛也是一样同时开赛捉对厮杀。只需要 5 天，也就是 O(log2N) 的时间，就能得到计算的结果。但是这种方式要求我们得有 16 个球场。因为在淘汰赛的第一轮，我们需要 16 场比赛同时进行。`对应到我们 CPU 的硬件上，就是需要更多的晶体管开关，来放下中间计算结果。`

![image-20230105211749437](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105211749437.png)

#### 10.3电路并行

上面我们说的并行加速的办法，看起来还是有点儿笨。我们回头来做一个抽象的思考。`之所以我们的计算会慢，核心原因其实是“顺序”计算，也就是说，要等前面的计算结果完成之后，我们才能得到后面的计算结果。`

最典型的例子就是我们上一讲讲的加法器。每一个全加器，都要等待上一个全加器，把对应的进位输入结果算出来，才能算下一位的输出。位数越多，越往高位走，等待前面的步骤就越多，这个等待的时间有个专门的名词，叫作`门延迟（Gate Delay）`。

每通过一个门电路，我们就要等待门电路的计算结果，就是一层的门电路延迟，我们一般给它取一个“T”作为符号。一个全加器，其实就已经有了 3T 的延迟（进位需要经过 3 个门电路）。而 4 位整数，最高位的计算需要等待前面三个全加器的进位结果，也就是要等 9T 的延迟。如果是 64 位整数，那就要变成 63×3=189T 的延迟。这可不是个小数字啊！

除了门延迟之外，还有一个问题就是`时钟频率`。在上面的顺序乘法计算里面，如果我们想要用更少的电路，计算的中间结果需要保存在寄存器里面，然后等待下一个时钟周期的到来，控制测试信号才能进行下一次移位和加法，这个延迟比上面的门延迟更可观。

那么，我们有什么办法可以解决这个问题呢？实际上，在我们进行加法的时候，如果相加的两个数是确定的，那高位是否会进位其实也是确定的。对于我们人来说，我们本身去做计算都是顺序执行的，所以要一步一步计算进位。但是，计算机是连结的各种线路。我们不用让计算机模拟人脑的思考方式，来连结线路。

那怎么才能把线路连结得复杂一点，让高位和低位的计算同时出结果呢？怎样才能让高位不需要等待低位的进位结果，而是把低位的所有输入信号都放进来，直接计算出高位的计算结果和进位结果呢？

`我们只要把进位部分的电路完全展开就好了。我们的半加器到全加器，再到加法器，都是用最基础的门电路组合而成的。门电路的计算逻辑，可以像我们做数学里面的多项式乘法一样完全展开。在展开之后呢，我们可以把原来需要较少的，但是有较多层前后计算依赖关系的门电路，展开成需要较多的，但是依赖关系更少的门电路。`

我在这里画了一个示意图，展示了一下我们加法器。如果我们完全展开电路，高位的进位和计算结果，可以和低位的计算结果同时获得。这个的核心原因是`电路是天然并行的，一个输入信号，可以同时传播到所有接通的线路当中`。

![image-20230105212159919](C:\Users\lan\AppData\Roaming\Typora\typora-user-images\image-20230105212159919.png)

如果一个 4 位整数最高位是否进位，展开门电路图，你会发现，我们只需要 3T 的延迟就可以拿到是否进位的计算结果。而对于 64 位的整数，也不会增加门延迟，只是从上往下复制这个电路，接入更多的信号而已。看到没？我们通过把电路变复杂，就解决了延迟的问题。

这个优化，本质上是利用了电路天然的并行性。电路只要接通，输入的信号自动传播到了所有接通的线路里面，这其实也是硬件和软件最大的不同。

==无论是这里把对应的门电路逻辑进行完全展开以减少门延迟，还是上面的乘法通过并行计算多个位的乘法，都是把我们完成一个计算的电路变复杂了。而电路变复杂了，也就意味着晶体管变多了。==

之前很多同学在我们讨论计算机的性能问题的时候，都提到，为什么晶体管的数量增加可以优化计算机的计算性能。实际上，这里的门电路展开和上面的并行计算乘法都是很好的例子。`我们通过更多的晶体管，就可以拿到更低的门延迟，以及用更少的时钟周期完成一个计算指令。`

#### 10.4总结延伸

讲到这里，相信你已经发现，我们通过之前两讲的 ALU 和门电路，搭建出来了乘法器。如果愿意的话，我们可以把很多在生活中不得不顺序执行的事情，通过简单地连结一下线路，就变成并行执行了。这是因为，硬件电路有一个很大的特点，那就是信号都是实时传输的。

我们也看到了，通过精巧地设计电路，用较少的门电路和寄存器，就能够计算完成乘法这样相对复杂的运算。==是用更少更简单的电路，但是需要更长的门延迟和时钟周期；还是用更复杂的电路，但是更短的门延迟和时钟周期来计算一个复杂的指令，这之间的权衡，其实就是计算机体系结构中 RISC 和 CISC 的经典历史路线之争。==

#### 10.5推荐阅读

如果还有什么细节你觉得还没有彻底弄明白，我推荐你看一看《计算机组成与设计：硬件 / 软件接口》的 3.3 节。

#### 10.6课后思考

这一讲里，我为你讲解了乘法器是怎么实现的。那么，请你想一想，如果我们想要用电路实现一个除法器，应该怎么做呢？需要注意一下，除法器除了要计算除法的商之外，还要计算出对应的余数。

